<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reddit Script Writer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600&display=swap" rel="stylesheet">
<style>
    :root {
        --primary: #368CFF;
        --secondary: #1F2A44;
        --background: #0A0A0A;
        --text: #E0E0E0;
        --bubble-user: #368CFF;
        --bubble-ai: #2A2F4A;
        --border-radius: 20px;
        --shadow: 0px 6px 24px rgba(0, 0, 0, 0.5);
        --side-bg: #1A1A2E;
        --highlight: #3A3F5A;
    }

    [data-theme="light"] {
        --primary: #368CFF;
        --secondary: #E6F0FA;
        --background: #F5F7FA;
        --text: #2E2E2E;
        --bubble-user: #368CFF;
        --bubble-ai: #DDE4EA;
        --shadow: 0px 6px 24px rgba(0, 0, 0, 0.15);
        --side-bg: #E0E6ED;
        --highlight: #B3C8E6;
    }
    
    [data-theme-transitioning] {
        transition: color 0.5s ease, background-color 0.5s ease;
    }
    
    body {
        background-color: var(--background);
        color: var(--text);
        font-family: 'Space Grotesk', sans-serif;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        margin: 0;
        padding: 1rem;
        position: relative;
        transition: background-color 0.3s ease, color 0.3s ease;
        overflow: hidden;
    }

    #bgGif {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        z-index: -1;
        margin: 0;
        padding: 0;
        border: none;
        pointer-events: none;
    }

    .chat-bubble-wrapper {
        display: flex;
        align-items: center;
        width: 100%;
    }

    .chat-bubble-wrapper.user {
        justify-content: flex-end; /* Bubble on right */
    }

    .chat-bubble-wrapper.ai {
        justify-content: flex-start; /* Bubble on left */
    }

    .chat-bubble {
        padding: 16px 20px;
        border-radius: var(--border-radius);
        max-width: 75%;
        font-size: 16px;
        line-height: 1.5;
        box-shadow: var(--shadow);
        word-wrap: break-word;
        white-space: pre-wrap;
        background: linear-gradient(135deg, var(--bubble-ai), var(--secondary));
        transition: background 0.3s ease, color 0.3s ease, transform 0.3s ease, box-shadow 0.3s ease;
        transform: perspective(500px) translateZ(10px);
        animation: slideUp 0.4s cubic-bezier(0.22, 0.61, 0.36, 1);
    }

    .chat-bubble:hover {
        box-shadow: 0px 10px 30px rgba(0, 0, 0, 0.5);
        transform: perspective(500px) translateZ(15px);
    }

    .chat-bubble.user {
        background: linear-gradient(135deg, var(--bubble-user), #357ABD);
        color: white;
    }

    .chat-bubble.ai {
        color: var(--text);
    }

    @keyframes slideUp {
        from { 
            transform: perspective(500px) translateY(30px) translateZ(0); 
            opacity: 0; 
        }
        to { 
            transform: perspective(500px) translateY(0) translateZ(10px); 
            opacity: 1; 
        }
    }

    /* Improved placeholder loading animation */
    .chat-bubble.placeholder {
        background: linear-gradient(135deg, var(--bubble-ai), #333);
        animation: pulse 1.5s infinite alternate;
    }

    @keyframes pulse {
        0% {
            opacity: 0.7;
            transform: perspective(500px) translateZ(10px);
        }
        100% {
            opacity: 1;
            transform: perspective(500px) translateZ(15px);
        }
    }

    .chat-bubble.editable {
        padding: 16px 20px;
        background: linear-gradient(135deg, #555, #333);
        border: 1px solid var(--primary);
        white-space: normal;
        min-height: 40px;
        height: auto; /* Allow bubble to grow with textarea */
    }

    .chat-bubble.editable textarea {
        width: 100%;
        background: transparent;
        border: none;
        color: white;
        font-size: 16px;
        line-height: 1.5;
        resize: none;
        outline: none;
        padding: 0;
        min-height: 40px;
        max-height: 300px; /* Increased for big messages */
        overflow-y: auto;
        scrollbar-width: thin;
        scrollbar-color: rgba(255, 255, 255, 0.3) rgba(0, 0, 0, 0);
    }

    .chat-bubble.editable textarea::-webkit-scrollbar {
        width: 6px;
    }

    .chat-bubble.editable textarea::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.3);
        border-radius: 4px;
    }

    /* Improved emoji button styles */
    .retry-button, .quote-button, .copy-button, .edit-button {
        background: transparent;
        border: none;
        color: rgba(255, 255, 255, 0.85); /* Darker, more visible emojis */
        cursor: pointer;
        font-size: 18px;
        opacity: 0; /* Hidden by default */
        transition: opacity 0.2s ease, transform 0.2s ease;
        margin: 0 5px;
        transform-origin: center;
    }

    /* Only show buttons when hovering over the message container */
    .chat-bubble-wrapper:hover .retry-button,
    .chat-bubble-wrapper:hover .quote-button,
    .chat-bubble-wrapper:hover .copy-button,
    .chat-bubble-wrapper:hover .edit-button {
        opacity: 0.85; /* More visible when hovered */
    }

    /* Full opacity and scale effect on direct button hover */
    .retry-button:hover, .quote-button:hover, .copy-button:hover, .edit-button:hover {
        opacity: 1;
        transform: scale(1.2);
    }

    .chat-bubble-wrapper.user .edit-button {
        color: rgba(255, 255, 255, 0.85); /* Darker for user messages */
        order: -1; /* Places emoji before bubble */
        margin-right: 10px; /* Reduced space from bubble */
    }

    .chat-bubble-wrapper.ai .quote-button {
        order: 1; /* Places emojis after bubble */
        margin-left: 8px; /* Initial spacing from bubble */
    }

    .chat-bubble-wrapper.ai .quote-button,
    .chat-bubble-wrapper.ai .retry-button,
    .chat-bubble-wrapper.ai .copy-button {
        margin-left: 8px; /* Consistent spacing between AI icons */
    }

    .settings-button {
        position: absolute;
        top: 50%;
        right: 20px;
        transform: translateY(-50%);
        background: transparent;
        border: none;
        color: var(--primary);
        cursor: pointer;
        font-size: 36px;
        z-index: 100;
        padding: 8px;
        transition: transform 0.2s ease;
    }
    
    .settings-button:hover {
        transform: translateY(-50%) scale(1.1);
    }

    .settings-menu {
        display: none;
        position: absolute;
        top: 65px;
        right: 20px;
        background: linear-gradient(135deg, var(--side-bg), var(--secondary));
        border-radius: var(--border-radius);
        box-shadow: var(--shadow);
        padding: 20px;
        z-index: 20;
        min-width: 200px;
        transform: perspective(500px) translateZ(10px);
        transition: background 0.3s ease, transform 0.3s ease;
        transform-origin: top right;
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
    }

    .settings-menu.active {
        display: block;
        animation: smoothSlideIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
    }

    @keyframes smoothSlideIn {
        from { 
            transform: perspective(500px) translateZ(0) scale(0.95) translateY(-10px); 
            opacity: 0; 
        }
        to { 
            transform: perspective(500px) translateZ(10px) scale(1) translateY(0); 
            opacity: 1; 
        }
    }

    .settings-menu button {
        display: block;
        width: 100%;
        padding: 12px;
        margin: 8px 0;
        border: none;
        background: linear-gradient(135deg, var(--secondary), var(--side-bg));
        color: var(--text);
        border-radius: 10px;
        cursor: pointer;
        box-shadow: var(--shadow);
        transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.2s ease;
        font-size: 16px;
    }

    .settings-menu button:hover {
        transform: translateY(-3px) translateZ(5px);
        box-shadow: 0px 8px 20px rgba(0, 0, 0, 0.3);
    }

    .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        z-index: 30;
        justify-content: center;
        align-items: center;
        backdrop-filter: blur(5px);
    }

    .modal.active {
        display: flex;
        animation: fadeIn 0.4s cubic-bezier(0.22, 0.61, 0.36, 1);
    }

    @keyframes fadeIn {
        from { 
            opacity: 0; 
            backdrop-filter: blur(0px);
        }
        to { 
            opacity: 1; 
            backdrop-filter: blur(5px);
        }
    }

    @keyframes smoothPopIn {
        from { 
            transform: perspective(500px) translateZ(0) scale(0.9); 
            opacity: 0; 
            box-shadow: 0px 5px 20px rgba(0, 0, 0, 0.3);
        }
        to { 
            transform: perspective(500px) translateZ(20px) scale(1); 
            opacity: 1; 
            box-shadow: 0px 15px 40px rgba(0, 0, 0, 0.5);
        }
    }

    .modal-content {
        background: linear-gradient(135deg, var(--side-bg), var(--secondary));
        padding: 24px;
        border-radius: var(--border-radius);
        max-width: 505px;
        width: 85%;
        box-shadow: 0px 15px 40px rgba(0, 0, 0, 0.5);
        transform: perspective(500px) translateZ(20px);
        transition: all 0.3s cubic-bezier(0.165, 0.84, 0.44, 1);
        animation: smoothPopIn 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        box-sizing: border-box;
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
    }

    .modal h2 {
        color: var(--primary);
        margin-bottom: 16px;
        font-size: 26px;
    }

    .key-display {
        background: var(--secondary);
        padding: 10px;
        border-radius: 8px;
        margin: 10px 0;
        word-break: break-all;
        box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.2);
        transition: background 0.3s ease;
    }

    .story-input {
        width: calc(100% - 12px);
        height: 100px;
        padding: 8px;
        border-radius: 10px;
        background: var(--side-bg);
        border: 1px solid rgba(255, 255, 255, 0.1);
        color: var(--text);
        font-size: 16px;
        margin: 13px 0;
        resize: none;
        box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.2);
        max-height: 100px;
        overflow-y: auto;
        box-sizing: border-box;
        transition: all 0.3s ease;
    }

    .story-input:focus {
        outline: none;
        border-color: var(--primary);
        background: var(--secondary);
        box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.2), 0 0 0 2px rgba(54, 140, 255, 0.2);
    }

    .close-modal {
        background: linear-gradient(135deg, var(--primary), #357ABD);
        color: white;
        border: none;
        padding: 10px 19px;
        border-radius: 10px;
        cursor: pointer;
        margin-top: 16px;
        box-shadow: var(--shadow);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        font-size: 16px;
    }

    .close-modal:hover {
        transform: translateY(-3px) translateZ(5px);
        box-shadow: 0px 8px 20px rgba(0, 0, 0, 0.3);
    }
    
    .yt-container {
        display: flex;
        gap: 10px;
    }
    
    .yt-link-input,
    .yt-additional-input {
        width: calc(50% - 12px);
        height: 100px;
        padding: 8px;
        border-radius: 10px;
        background: var(--side-bg);
        border: 1px solid rgba(255, 255, 255, 0.1);
        color: var(--text);
        font-size: 16px;
        margin: 13px 0;
        resize: none;
        box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.2);
        max-height: 100px;
        overflow-y: auto;
        transition: all 0.3s ease;
    }
    
    .yt-link-input:focus,
    .yt-additional-input:focus {
        outline: none;
        border-color: var(--primary);
        background: var(--secondary);
        box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.2), 0 0 0 2px rgba(54, 140, 255, 0.2);
    }

    #accessKeyLogin, #apiKeyLogin {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background: linear-gradient(135deg, var(--secondary), var(--side-bg));
        padding: 2rem;
        border-radius: var(--border-radius);
        box-shadow: var(--shadow);
        width: 100%;
        max-width: 400px;
        position: fixed;
        left: 50%;
        top: 50%;
        transform: perspective(500px) translate(-50%, -50%) translateZ(20px);
        transition: background 0.3s ease, transform 0.3s ease;
        animation: loginPopIn 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
    }

    @keyframes loginPopIn {
        from { 
            transform: perspective(500px) translate(-50%, -50%) translateZ(0) scale(0.9); 
            opacity: 0; 
        }
        to { 
            transform: perspective(500px) translate(-50%, -50%) translateZ(20px) scale(1); 
            opacity: 1; 
        }
    }

    #apiKeyLogin {
        display: none;
    }

    .login-header {
        font-size: 24px;
        font-weight: 600;
        margin-bottom: 1.5rem;
        color: var(--primary);
        text-transform: uppercase;
        letter-spacing: 1px;
        text-align: center;
        width: 100%;
    }

    .login-input {
        width: 100%;
        padding: 12px;
        margin: 10px 0;
        border-radius: var(--border-radius);
        background: var(--side-bg);
        border: 1px solid #333;
        color: var(--text);
        font-size: 16px;
        text-align: center;
        box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.2);
        transition: all 0.3s ease;
    }

    .login-input:focus {
        outline: none;
        border-color: var(--primary);
        background: var(--secondary);
        box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.2), 0 0 0 2px rgba(54, 140, 255, 0.2);
    }

    .login-button {
        width: 100%;
        padding: 12px;
        margin-top: 20px;
        border-radius: var(--border-radius);
        background: linear-gradient(135deg, var(--primary), #357ABD);
        color: white;
        font-size: 16px;
        font-weight: 500;
        cursor: pointer;
        box-shadow: var(--shadow);
        transition: all 0.3s ease;
        border: none;
    }

    .login-button:hover {
        transform: translateY(-3px) translateZ(5px);
        box-shadow: 0px 8px 15px rgba(0, 0, 0, 0.3);
    }

    .success-message {
        color: #4CAF50;
        margin-top: 10px;
        font-size: 14px;
        opacity: 0;
        transition: opacity 0.3s ease;
        text-align: center;
        width: 100%;
    }

    .chat-container {
        display: none;
        flex-direction: row;
        width: clamp(47.5%, 50%, 1200px);
        max-width: 90%;
        height: 90vh;
        position: relative;
        overflow: hidden;
        transform: perspective(500px) translateZ(10px);
        filter: drop-shadow(0 10px 30px rgba(0, 0, 0, 0.8));
    }

    .chat-main {
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        border-radius: var(--border-radius);
        overflow: hidden;
        background: linear-gradient(135deg, var(--secondary), var(--side-bg));
        box-shadow: 0px 15px 60px rgba(0, 0, 0, 0.9);
        position: relative;
        z-index: 5;
        transition: background 0.3s ease;
        padding: 20px;
    }

    .header {
        background: linear-gradient(135deg, var(--secondary), var(--side-bg));
        padding: 20px;
        text-align: center;
        font-size: 36px;
        font-weight: 600;
        letter-spacing: 1px;
        color: var(--primary);
        text-transform: uppercase;
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.25);
        transition: background 0.3s ease, color 0.3s ease;
        animation: glowMove 3s ease-in-out infinite;
        border-radius: var(--border-radius);
        margin-bottom: 20px;
    }

    @keyframes glowMove {
        0%, 100% { text-shadow: 0 0 5px var(--primary); transform: translateX(-2px) translateZ(0); }
        50% { text-shadow: 0 0 15px var(--primary), 0 0 25px var(--primary); transform: translateX(2px) translateZ(10px); }
    }
    
    .current-chat-indicator {
        background: var(--secondary);
        color: var(--text);
        font-size: 14px;
        padding: 6px 12px;
        border-radius: 6px;
        position: absolute;
        bottom: -15px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 10;
        white-space: nowrap;
        overflow: visible;
        max-width: 90%;
        text-transform: none;
        box-shadow: var(--shadow);
        transition: background 0.3s ease, color 0.3s ease;
    }

    .sidebar-toggle {
        position: absolute;
        left: 20px;
        top: 50%;
        transform: translateY(-50%);
        background: transparent;
        border: none;
        color: var(--primary);
        cursor: pointer;
        font-size: 36px;
        z-index: 10;
        padding: 8px;
        transition: transform 0.2s ease;
    }
    
    .sidebar-toggle:hover {
        transform: translateY(-50%) scale(1.1);
    }
    
    .sidebar-edge {
        position: absolute;
        left: 0;
        top: 0;
        height: 100%;
        width: 4px;
        background: var(--primary);
        opacity: 0.4;
        cursor: pointer;
        z-index: 15;
        transition: opacity 0.3s ease;
    }
    
    .sidebar-edge:hover {
        opacity: 0.8;
    }

    .chat-box {
        position: relative;
        flex-grow: 1;
        overflow-y: auto;
        padding: 20px;
        display: flex;
        flex-direction: column;
        gap: 25px; /* Controls spacing between bubbles */
        scrollbar-width: thin;
        scrollbar-color: rgba(255, 255, 255, 0.3) rgba(0, 0, 0, 0);
        background: linear-gradient(135deg, var(--side-bg), var(--secondary));
        transition: background 0.3s ease;
        border-radius: var(--border-radius);
        margin-bottom: 20px;
    }

    .chat-box::-webkit-scrollbar {
        width: 6px;
    }

    .chat-box::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.3);
        border-radius: 4px;
    }

    .full-screen-button {
        background: transparent;
        border: none;
        color: grey;
        cursor: pointer;
        font-size: 20px;
        padding: 8px;
        position: absolute;
        top: 10px;
        left: 10px;
        opacity: 0.5;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 10;
    }
    
    .full-screen-button:hover {
        opacity: 1;
        transform: scale(1.1);
    }

    .chat-container.full-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        max-width: 100%;
        z-index: 1000;
        background: var(--background);
        padding: 0;
        box-sizing: border-box;
    }

    .chat-container.full-screen .chat-main {
        width: 100%;
        height: 100%;
        padding: 20px;
        box-sizing: border-box;
        border-radius: 0;
    }

    .chat-container.full-screen .chat-box {
        padding-top: 40px;
        margin-bottom: 0;
        flex-grow: 1;
        height: calc(100% - 140px); /* Adjust for header and input heights */
    }

    .chat-container.full-screen .input-container {
        position: relative;
        bottom: 0;
        width: 100%;
        margin: 0;
        padding: 15px 20px;
        box-sizing: border-box;
        z-index: 10;
    }

    .input-container {
        display: flex;
        flex-direction: column;
        padding: 15px;
        background: linear-gradient(135deg, var(--secondary), var(--side-bg));
        gap: 15px;
        box-shadow: 0 -5px 20px rgba(0, 0, 0, 0.2);
        transition: background 0.3s ease;
        border-radius: var(--border-radius);
        position: relative;
    }
    
    .preset-buttons {
        display: flex;
        gap: 8px;
        justify-content: flex-end;
        align-items: center;
        width: 100%;
        overflow: hidden;
        white-space: nowrap;
        position: relative;
        z-index: 100;
        margin-bottom: 10px;
        padding-right: 15px;
    }
    
    .preset-buttons button {
        background: linear-gradient(135deg, var(--primary), #357ABD);
        padding: 2px 5px;
        border-radius: 6px;
        color: white;
        font-size: 8px;
        font-weight: 600;
        cursor: pointer;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        transition: all 0.2s ease-out;
        border: none;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        line-height: 1.2;
        position: relative;
        z-index: 100;
    }
    
    .preset-buttons button:hover {
        transform: scale(1.05) translateY(-2px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }

    /* Save button pulse animation */
    @keyframes savePulse {
        0% {
            box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.7);
        }
        70% {
            box-shadow: 0 0 0 10px rgba(76, 175, 80, 0);
        }
        100% {
            box-shadow: 0 0 0 0 rgba(76, 175, 80, 0);
        }
    }

    .preset-buttons button:last-child {
        animation: savePulse 2s infinite;
    }
    
    @media (max-width: 480px) {
        .preset-buttons {
            gap: 6px;
            margin-bottom: 8px;
            padding-right: 10px;
        }
        
        .preset-buttons button {
            padding: 1px 3px;
            font-size: 7px;
        }
    }        

    .input-row {
        display: flex;
        gap: 15px;
        align-items: center;
    }
    
    .input-container textarea {
        flex-grow: 1;
        padding: 10px;
        border-radius: var(--border-radius);
        border: none;
        background: var(--side-bg);
        color: var(--text);
        font-size: 15px;
        line-height: 1.5;
        box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.2);
        transition: all 0.3s ease-in-out;
        resize: none;
        min-height: 40px;
        max-height: 130px;
        overflow-y: auto;
        scrollbar-width: thin;
        scrollbar-color: rgba(255, 255, 255, 0.3) rgba(0, 0, 0, 0);
    }

    .input-container textarea::-webkit-scrollbar {
        width: 6px;
    }

    .input-container textarea::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.3);
        border-radius: 4px;
    }

    .input-container textarea:focus {
        outline: none;
        background: var(--secondary);
        box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.2), 0 0 0 2px rgba(54, 140, 255, 0.2);
    }

    .input-container button {
        background: linear-gradient(135deg, var(--primary), #357ABD);
        padding: 10px 15px;
        border-radius: var(--border-radius);
        border: none;
        color: white;
        font-size: 18px;
        cursor: pointer;
        box-shadow: var(--shadow);
        transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.2s ease;
        white-space: nowrap;
    }

    .input-container button:hover {
        transform: translateY(-3px) translateZ(5px);
        box-shadow: 0px 8px 20px rgba(0, 0, 0, 0.3);
    }

    .input-container button.active {
        background: linear-gradient(135deg, #FF5555, #CC4444);
        cursor: pointer; /* Keep clickable for abort */
    }
    
    .side-extension {
        width: 300px;
        height: 100%;
        background: linear-gradient(180deg, var(--secondary) 0%, var(--side-bg) 100%);
        border-radius: var(--border-radius);
        box-shadow: var(--shadow);
        z-index: 20;
        padding: 25px;
        position: absolute;
        left: -310px;
        top: 0;
        transition: left 0.3s ease, background 0.3s ease;
        overflow-y: auto;
        visibility: hidden;
        transform: perspective(500px) translateZ(10px);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
    }

    .side-extension.active {
        left: 0;
        visibility: visible;
        animation: smoothSideSlideIn 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
    }
    
    @keyframes smoothSideSlideIn {
        from { 
            left: -310px; 
            opacity: 0.8; 
            box-shadow: 0px 5px 15px rgba(0, 0, 0, 0.2);
        }
        to { 
            left: 0; 
            opacity: 1; 
            box-shadow: var(--shadow);
        }
    }
    
    .side-extension.edge-only {
        left: -292px;
        visibility: visible;
    }

    .side-extension-header {
        font-size: 26px;
        font-weight: 700;
        color: var(--primary);
        margin-bottom: 30px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 2px solid rgba(255, 255, 255, 0.1);
        padding-bottom: 15px;
    }

    .close-sidebar {
        background: rgba(255, 255, 255, 0.1);
        border: none;
        color: var(--text);
        font-size: 20px;
        cursor: pointer;
        transition: transform 0.2s ease, background 0.2s ease;
        width: 36px;
        height: 36px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .close-sidebar:hover {
        transform: scale(1.1);
        background: rgba(255, 255, 255, 0.2);
    }

    .side-button {
        display: block;
        width: 100%;
        padding: 14px 18px;
        margin: 10px 0;
        background: linear-gradient(145deg, var(--secondary), var(--side-bg));
        color: var(--text);
        border-radius: 14px;
        border: none;
        cursor: pointer;
        text-align: left;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
        transition: all 0.3s ease;
        transform: perspective(500px) translateZ(5px);
        font-size: 16px;
        font-weight: 500;
        position: relative;
        overflow: hidden;
    }

    .side-button:hover {
        transform: perspective(500px) translateZ(10px) translateY(-2px);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
    }

    .side-button.new-chat {
        background: linear-gradient(135deg, var(--primary), #357ABD);
        color: white;
        padding: 16px 18px;
        margin-bottom: 20px;
        text-align: center;
        font-weight: 600;
        letter-spacing: 0.5px;
    }
    
    .side-button.new-chat:hover {
        background: linear-gradient(135deg, #4a97ff, #4389d9);
    }

    .side-button.current {
        background: linear-gradient(145deg, var(--highlight), var(--secondary));
        border-left: 4px solid var(--primary);
        padding-left: 14px;
        font-weight: bold;
    }
    
    .side-button.current::after {
        content: '';
        position: absolute;
        top: 0;
        right: 0;
        height: 100%;
        width: 4px;
        background: var(--primary);
    }
    
    .chat-actions {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        position: relative;
    }
    
    .delete-chat {
        background: linear-gradient(135deg, #FF5555, #CC4444);
        color: white;
        border: none;
        border-radius: 10px;
        padding: 8px 12px;
        font-size: 14px;
        cursor: pointer;
        box-shadow: var(--shadow);
        transition: all 0.3s ease;
        opacity: 0.9;
    }
    
    .delete-chat:hover {
        transform: scale(1.05) translateZ(5px);
        opacity: 1;
    }
    
    .saved-script-delete-button {
        background: linear-gradient(135deg, #FF5555, #CC4444);
        color: white;
        border: none;
        border-radius: 5px;
        padding: 5px 10px;
        cursor: pointer;
        font-size: 14px;
        transition: transform 0.2s ease;
        margin-left: 10px;
    }
    
    .saved-script-delete-button:hover {
        transform: scale(1.05);
    }

    /* Success message animation */
    @keyframes successFade {
        0% { 
            opacity: 0; 
            transform: translateY(10px);
        }
        10% { 
            opacity: 1; 
            transform: translateY(0);
        }
        90% { 
            opacity: 1; 
            transform: translateY(0);
        }
        100% { 
            opacity: 0; 
            transform: translateY(-10px);
        }
    }

    .success-notification {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(135deg, #4CAF50, #2E7D32);
        color: white;
        padding: 12px 24px;
        border-radius: 30px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        z-index: 1000;
        font-weight: 500;
        display: flex;
        align-items: center;
        gap: 8px;
        animation: successFade 3s forwards;
    }

    .success-notification::before {
        content: "✓";
        font-size: 18px;
        font-weight: bold;
    }
    
    .error-notification {
        background: linear-gradient(135deg, #FF5555, #CC4444);
    }
    
    .error-notification::before {
        content: "✗";
    }

    .full-page-loader {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        backdrop-filter: blur(5px);
    }
    
    .loader-content {
        text-align: center;
    }
    
    .spinner {
        width: 50px;
        height: 50px;
        border: 5px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top-color: var(--primary);
        animation: spin 1s ease-in-out infinite;
        margin: 0 auto 20px;
    }
    
    @keyframes spin {
        to { transform: rotate(360deg); }
    }
    
    .loader-text {
        color: white;
        font-size: 18px;
        font-weight: 500;
    }
    
    .fade-out {
        animation: fadeOut 0.5s forwards;
    }
    
    @keyframes fadeOut {
        from { opacity: 1; }
        to { opacity: 0; }
    }

    .animate-in {
        animation: slideIn 0.5s forwards;
    }
    
    @keyframes slideIn {
        from { 
            opacity: 0;
            transform: translateY(20px);
        }
        to { 
            opacity: 1;
            transform: translateY(0);
        }
    }

    @media (max-width: 480px) {
        .chat-container {
            width: 100%;
            height: 100vh;
            border-radius: 0;
            padding: 10px;
        }

        body { padding: 0; }

        .preset-buttons {
            padding: 5px;
            gap: 4px;
        }

        .preset-buttons button {
            padding: 3px 6px;
            font-size: 9px;
        }

        .side-extension {
            width: 250px;
            left: -260px;
        }

        .side-extension.active { left: 0; }
    }

    #ytLinkModal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        z-index: 30;
        justify-content: center;
        align-items: center;
        backdrop-filter: blur(5px);
    }

    #ytLinkModal.active {
        display: flex;
        animation: fadeIn 0.3s ease;
    }

    .yt-link-input {
        width: 90%;
        padding: 12px;
        margin: 10px auto;
        background: var(--side-bg);
        border: 1px solid rgba(255, 255, 255, 0.1);
        color: var(--text);
        font-size: 16px;
        box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.2);
        transition: all 0.3s ease;
        display: block;
    }

    .yt-link-input:focus {
        outline: none;
        border-color: var(--primary);
        background: var(--secondary);
        box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.2), 0 0 0 2px rgba(54, 140, 255, 0.2);
    }

    #savedScriptsContainer::-webkit-scrollbar {
        width: 6px;
    }

    #savedScriptsContainer::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.3);
        border-radius: 4px;
    }

    .saved-script {
        margin-bottom: 15px;
        padding: 10px;
        background: var(--side-bg);
        border-radius: 8px;
        white-space: pre-wrap;
        word-wrap: break-word;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    
    .saved-script:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }

    .script-separator {
        border-top: 1px dashed var(--primary);
        margin: 10px 0;
    }
    
    /* Mobile optimizations */
    .mobile-device .chat-bubble {
        max-width: 85%;
    }
    
    .mobile-device .chat-box {
        padding: 15px 10px;
    }
    
    .mobile-device .input-container {
        padding: 10px;
    }
    
    .mobile-device .preset-buttons button {
        font-size: 7px;
        padding: 1px 3px;
    }
    
    /* Improved emoji button spacing - Fix A */
    .chat-bubble-wrapper.ai .quote-button,
    .chat-bubble-wrapper.ai .retry-button,
    .chat-bubble-wrapper.ai .copy-button {
        margin-left: 12px; /* Increased from 8px */
    }
    
    /* Make emoji buttons closer together as a group - Fix C */
    .chat-bubble-wrapper.ai {
        display: flex;
        align-items: center;
    }
    
    .chat-bubble-wrapper.ai .quote-button,
    .chat-bubble-wrapper.ai .retry-button,
    .chat-bubble-wrapper.ai .copy-button {
        margin-left: 6px; /* Closer to each other */
    }
    
    /* Create visual grouping for emoji buttons - Fix C */
    .chat-bubble-wrapper.ai .chat-bubble {
        margin-right: 6px; /* Add space after bubble */
    }
    
</style>
</head>
<body>
    <img id="bgGif" src="https://media4.giphy.com/media/v1.Y2lkPTc5MGI3NjExNzJoeXZjbzcxbG52c2Nkemtxc2FvNXE1azFpNHZ3MXZoaXR5cHRjdSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/QTJMtK3tbkjTadk8as/giphy.gif" alt="Background animation">

    <div id="accessKeyLogin">
        <div class="login-header">Access Verification</div>
        <input type="password" id="accessKey" class="login-input" placeholder="Enter your access key">
        <button onclick="verifyAccessKey()" class="login-button">Continue</button>
        <div id="accessKeyMessage" class="success-message"></div>
    </div>

    <div id="apiKeyLogin">
        <div class="login-header">API Verification</div>
        <input type="password" id="apiKey" class="login-input" placeholder="Enter your Claude AI API key">
        <button onclick="verifyApiKey()" class="login-button">Login</button>
        <div id="apiKeyMessage" class="success-message"></div>
    </div>

    <div id="chatInterface" class="chat-container">
        <div class="side-extension" id="sideExtension">
            <div class="side-extension-header">
                <span>Chat Library</span>
                <button class="close-sidebar" onclick="hideSidebar()">×</button>
            </div>
            <button class="side-button new-chat" onclick="newChat()">New Chat +</button>
            <div id="chatList"></div>
            <div class="sidebar-edge" onclick="toggleSideExtension()"></div>
        </div>
        
        <div class="chat-main">
            <div class="header">
                <button onclick="toggleSideExtension()" id="sidebarToggle" class="sidebar-toggle">📚</button>
                Reddit Script Writer
                <button onclick="toggleSettings()" id="settingsButton" class="settings-button">⚙️</button>
                <div class="current-chat-indicator" id="currentChatIndicator">Chat 1</div>
            </div>
            <div class="settings-menu" id="settingsMenu">
                <button onclick="showKeys()">🔑 View Keys</button>
                <button onclick="toggleTheme()" id="themeToggle">🌗 Toggle Theme</button>
                <button onclick="showSavedScripts()">📜 Saved Scripts</button>
                <button onclick="logout()">🚪 Logout</button>
            </div>
            <div id="chatBox" class="chat-box">
                <button onclick="toggleFullScreen()" id="fullScreenButton" class="full-screen-button">⛶</button>
            </div>
            <div class="input-container">
                <div class="preset-buttons" id="presetButtons">
                    <button onclick="showStoryModal()">Add Story</button>
                    <button onclick="showYtLinkModal()">YT Link</button>
                    <button onclick="setPrompt('REGEN'); sendMessage()">RE-GEN</button>
                    <button onclick="setPrompt('SAME'); sendMessage()">SAME</button>
                    <button onclick="setPrompt('MENU'); sendMessage()">MENU</button>
                    <button onclick="saveScript()" style="background: linear-gradient(135deg, #4CAF50, #388E3C);">SAVE</button>
                </div>
                <div class="input-row">
                    <textarea id="userInput" placeholder="Type your message..." rows="1" oninput="autoExpand(this)"></textarea>
                    <button id="sendStopButton" onclick="toggleSendStop()">➤</button>
                </div>
            </div>
        </div>
    </div>

    <div id="keysModal" class="modal">
        <div class="modal-content">
            <h2>Your Keys</h2>
            <div>
                <p>Access Key:</p>
                <div id="accessKeyDisplay" class="key-display"></div>
            </div>
            <div>
                <p>API Key:</p>
                <div id="apiKeyDisplay" class="key-display"></div>
            </div>
            <button onclick="closeModal('keysModal')" class="close-modal">Close</button>
        </div>
    </div>

    <div id="storyModal" class="modal">
        <div class="modal-content">
            <h2>Paste Your Reddit Story</h2>
            <textarea id="storyInput" class="story-input" placeholder="Paste the viral Reddit story here..."></textarea>
            <div style="display: flex; justify-content: space-between; margin-top: 16px; width: 100%; box-sizing: border-box;">
                <button onclick="submitStory()" class="close-modal" style="flex: 1; margin-right: 12px; padding: 10px 0; box-sizing: border-box; font-size: 16px;">Submit</button>
                <button onclick="closeModal('storyModal')" class="close-modal" style="flex: 1; margin-left: 12px; background: #555; padding: 10px 0; box-sizing: border-box; font-size: 16px;">Cancel</button>
            </div>
        </div>
    </div>

    <div id="ytLinkModal" class="modal">
        <div class="modal-content">
            <h2>Add YouTube Link</h2>
            <div class="yt-container">
                <textarea id="ytLinkInput" class="yt-link-input" placeholder="Paste YouTube URL here..."></textarea>
                <textarea id="ytAdditionalInput" class="yt-additional-input" placeholder="Additional content (details, context, etc.)..."></textarea>
            </div>
            <div style="display: flex; justify-content: space-between; margin-top: 16px; width: 100%; box-sizing: border-box;">
                <button onclick="submitYtLink()" class="close-modal" style="flex: 1; margin-right: 12px; padding: 10px 0; box-sizing: border-box; font-size: 16px;">Submit</button>
                <button onclick="closeModal('ytLinkModal')" class="close-modal" style="flex: 1; margin-left: 12px; background: #555; padding: 10px 0; box-sizing: border-box; font-size: 16px;">Cancel</button>
            </div>
        </div>
    </div>

    <div id="savedScriptsModal" class="modal">
        <div class="modal-content">
            <h2>Saved Scripts</h2>
            <div id="savedScriptsContainer" style="max-height: 400px; overflow-y: auto; background: var(--secondary); padding: 15px; border-radius: 10px; margin: 10px 0;">
                <div id="savedScriptsList"></div>
            </div>
            <div style="display: flex; justify-content: space-between; margin-top: 16px;">
                <button onclick="downloadScripts()" class="close-modal" style="flex: 1; margin-right: 8px; padding: 10px 0;">Download</button>
                <button onclick="clearSavedScripts()" class="close-modal" style="flex: 1; margin: 0 8px; background: #FF5555; padding: 10px 0;">Clear</button>
                <button onclick="closeModal('savedScriptsModal')" class="close-modal" style="flex: 1; margin-left: 8px; padding: 10px 0;">Close</button>
            </div>
        </div>
    </div>

    <script>
    const TEMPLATE_TEXT = `Here is a viral Reddit story:

'[Insert the viral story you provide.]'

--------------------

Write a completely original 60-second YouTube Shorts script inspired by this story. The new script should keep the core idea but feel like a fresh, unique take—not just a reworded version. Add a new twist or perspective to make it stand out. The script MUST begin with the exact hook provided—word for word. The hook is the first sentence ending with the first "?", "!", ".", or "…". You are NOT allowed to modify, rewrite, or replace the hook in any way. The story must flow directly from the given hook and fully answer it. Make the story feel raw and real, as if someone is genuinely sharing their experience. Include small, everyday details to enhance authenticity—things people actually say and do. The tone should be natural and conversational, avoiding anything scripted or artificial. Use the database as a reference for tone, pacing, and storytelling style, ensuring it aligns with successful viral patterns while remaining 100% original—not a copy, not just a few details changed. The final story must be between 1,400-1,500 characters (~250 words) for a fast-paced 60-second read. Maintain a natural flow, making it sound like a real person recounting their own experience.`;

    const YT_TEMPLATE_TEXT = `[Insert additional context here, if provided.]

--------------------

Here is a viral Reddit story:

'[Insert the viral story you provide.]'

--------------------

Write a completely original 60-second YouTube Shorts script inspired by this story. The new script should keep the core idea but feel like a fresh, unique take—not just a reworded version. Add a new twist or perspective to make it stand out. The script MUST begin with the exact hook provided—word for word. The hook is the first sentence ending with the first "?", "!", ".", or "…". You are NOT allowed to modify, rewrite, or replace the hook in any way. The story must flow directly from the given hook and fully answer it. Make the story feel raw and real, as if someone is genuinely sharing their experience. Include small, everyday details to enhance authenticity—things people actually say and do. The tone should be natural and conversational, avoiding anything scripted or artificial. Use the database as a reference for tone, pacing, and storytelling style, ensuring it aligns with successful viral patterns while remaining 100% original—not a copy, not just a few details changed. The final story must be between 1,400-1,500 characters (~250 words) for a fast-paced 60-second read. Maintain a natural flow, making it sound like a real person recounting their own experience.`;

    const cookingMessages = [
        "Brewing some script juice...",
        "Squeezing out the sauce...",
        "Crafting TikTok gold...",
        "Mixing viral vibes...",
        "Cooking up social magic...",
        "Stirring some scroll-stopping content...",
        "Blending the next big script...",
        "Whipping up Insta-worthy lines..."
    ];
    
    let isRequestPending = false;
    let abortController = null;
    let currentStory = ''; // To store the story for display in user bubble
    let currentTranscript = ''; // To store the transcript for YT link submissions

    function setCookie(name, value, days) {
        let expires = "";
        if (days) {
            const date = new Date();
            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
            expires = "; expires=" + date.toUTCString();
        }
        document.cookie = name + "=" + encodeURIComponent(value) + expires + "; path=/";
    }

    function getCookie(name) {
        const nameEQ = name + "=";
        const ca = document.cookie.split(';');
        for(let i = 0; i < ca.length; i++) {
            let c = ca[i];
            while (c.charAt(0) == ' ') c = c.substring(1, c.length);
            if (c.indexOf(nameEQ) == 0) return decodeURIComponent(c.substring(nameEQ.length, c.length));
        }
        return null;
    }

    function deleteCookie(name) {
        document.cookie = name + '=; Max-Age=-99999999;';
    }

    function setChatSessions(sessions) {
        setCookie('chatSessions', JSON.stringify(sessions), 7);
    }

    function getChatSessions() {
        const sessions = getCookie('chatSessions');
        return sessions ? JSON.parse(sessions) : {};
    }

    async function fetchSavedScripts() {
        try {
            const response = await fetch('/api/saved-scripts');
            if (!response.ok) throw new Error('Failed to fetch saved scripts');
            const data = await response.json();
            return data.scripts;
        } catch (error) {
            console.error('Error fetching saved scripts:', error);
            return [];
        }
    }

    function showModal(modalId) {
        const modal = document.getElementById(modalId);
        document.body.style.overflow = 'hidden'; // Prevent background scrolling
        modal.classList.add('active');
        
        // Add escape key handler
        const escHandler = (e) => {
            if (e.key === 'Escape') {
                closeModal(modalId);
                document.removeEventListener('keydown', escHandler);
            }
        };
        document.addEventListener('keydown', escHandler);
        
        // Focus on the first input if available
        setTimeout(() => {
            const firstInput = modal.querySelector('input, textarea');
            if (firstInput) firstInput.focus();
        }, 100);
    }

    function closeModal(modalId) {
        const modal = document.getElementById(modalId);
        document.body.style.overflow = ''; // Restore scrolling
        modal.classList.remove('active');
        
        // Reset form inputs if any
        const form = modal.querySelector('form');
        if (form) form.reset();
    }

    function showStoryModal() {
        document.getElementById('storyInput').value = '';
        showModal('storyModal');
    }

    function showYtLinkModal() {
        const ytLinkInput = document.getElementById('ytLinkInput');
        const ytAdditionalInput = document.getElementById('ytAdditionalInput');
        if (ytLinkInput && ytAdditionalInput) {
            ytLinkInput.value = '';
            ytAdditionalInput.value = '';
            showModal('ytLinkModal');
        } else {
            console.error('YT link modal elements not found');
        }
    }
    
    async function fetchYouTubeTranscript(videoUrl) {
        try {
            showLoading();
            const response = await fetch('/api/youtube-transcript', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ url: videoUrl })
            });
            hideLoading();
            
            if (!response.ok) throw new Error('Failed to fetch transcript');
            const data = await response.json();
            return data.transcript;
        } catch (error) {
            hideLoading();
            console.error('Transcript fetch error:', error);
            return "Error: Couldn't fetch transcript. Please try again.";
        }
    }
    
    async function submitYtLink() {
        const ytLinkInput = document.getElementById('ytLinkInput');
        const ytAdditionalInput = document.getElementById('ytAdditionalInput');
        const userInput = document.getElementById("userInput");
        const chatBox = document.getElementById("chatBox");
        if (!ytLinkInput || !ytAdditionalInput || !chatBox || !userInput) {
            console.error('YT link modal, userInput, or chatBox not found');
            return;
        }

        const ytLink = ytLinkInput.value.trim();
        const additionalContent = ytAdditionalInput.value.trim();
        if (!ytLink) {
            showNotification('Please enter a YouTube URL.', 'error');
            return;
        }

        closeModal('ytLinkModal');
        
        const loadingBubble = document.createElement("div");
        loadingBubble.className = "chat-bubble ai";
        loadingBubble.textContent = "Fetching YouTube transcript...";
        
        const loadingWrapper = document.createElement("div");
        loadingWrapper.className = "chat-bubble-wrapper ai";
        loadingWrapper.appendChild(loadingBubble);
        
        chatBox.appendChild(loadingWrapper);
        chatBox.scrollTop = chatBox.scrollHeight;

        const transcript = await fetchYouTubeTranscript(ytLink);

        loadingWrapper.remove();

        if (transcript.startsWith("Error:")) {
            const errorBubble = document.createElement("div");
            errorBubble.className = "chat-bubble ai";
            errorBubble.textContent = transcript;
            
            const errorWrapper = document.createElement("div");
            errorWrapper.className = "chat-bubble-wrapper ai";
            errorWrapper.appendChild(errorBubble);
            
            chatBox.appendChild(errorWrapper);
            chatBox.scrollTop = chatBox.scrollHeight;
            showNotification(transcript, 'error');
            return;
        }

        currentTranscript = transcript; // Store the transcript for display
        let fullPrompt = YT_TEMPLATE_TEXT;
        fullPrompt = fullPrompt.replace('[Insert additional context here, if provided.]', additionalContent || '');
        fullPrompt = fullPrompt.replace('[Insert the viral story you provide.]', transcript);
        setPrompt(fullPrompt);
        userInput.value = ''; // Clear the input field
        autoExpand(userInput);
        sendMessage();
        showNotification('YouTube transcript processed successfully!');
    }  

    function submitStory() {
        const storyContent = document.getElementById('storyInput').value.trim();
        const userInput = document.getElementById("userInput");
        if (!storyContent) {
            showNotification('Please paste a Reddit story before submitting.', 'error');
            return;
        }
        
        currentStory = storyContent; // Store the story for display
        const fullPrompt = TEMPLATE_TEXT.replace('[Insert the viral story you provide.]', storyContent);
        setPrompt(fullPrompt);
        userInput.value = ''; // Clear the input field
        autoExpand(userInput);
        closeModal('storyModal');
        sendMessage();
        showNotification('Story submitted successfully!');
    }

    let currentAccessKey = '';
    let currentApiKey = '';
    let chatSessions = getChatSessions() || {};
    let sessionNames = getSavedSessionNames() || {};
    let currentSessionId = '';
    
    if (Object.keys(chatSessions).length === 0) {
        currentSessionId = Date.now().toString();
        chatSessions[currentSessionId] = [];
        sessionNames[currentSessionId] = `Chat 1`;
        setChatSessions(chatSessions);
        setCookie('sessionNames', JSON.stringify(sessionNames), 7);
    } else {
        currentSessionId = Object.keys(chatSessions)[0];
    }

    function getSavedSessionNames() {
        const names = getCookie('sessionNames');
        return names ? JSON.parse(names) : {};
    }

    function verifyAccessKey() {
        const accessKey = document.getElementById('accessKey').value.trim();
        const messageElement = document.getElementById('accessKeyMessage');
        
        if (!accessKey) {
            messageElement.style.color = "#f44336";
            messageElement.textContent = "Please enter an access code.";
            messageElement.style.opacity = "1";
            return;
        }

        showLoading();
        fetch('/api/validate-code', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ code: accessKey })
        })
        .then(response => {
            hideLoading();
            if (!response.ok) throw new Error('Invalid code');
            return response.json();
        })
        .then(data => {
            if (data.success) {
                currentAccessKey = accessKey;
                setCookie('accessKey', accessKey, 7);
                messageElement.style.color = "#4CAF50";
                messageElement.textContent = "Access verified successfully!";
                messageElement.style.opacity = "1";
                setTimeout(() => {
                    document.getElementById('accessKeyLogin').style.display = 'none';
                    document.getElementById('apiKeyLogin').style.display = 'flex';
                    messageElement.style.opacity = '0';
                }, 1000);
            }
        })
        .catch(error => {
            messageElement.style.color = "#f44336";
            messageElement.textContent = "Invalid or used access code.";
            messageElement.style.opacity = "1";
        });
    }

    function verifyApiKey() {
        const apiKey = document.getElementById('apiKey').value.trim();
        const messageElement = document.getElementById('apiKeyMessage');
        
        if (!apiKey || !apiKey.startsWith('sk-ant-')) {
            messageElement.style.color = "#f44336";
            messageElement.textContent = "Invalid API key format.";
            messageElement.style.opacity = "1";
            return;
        }

        currentApiKey = apiKey;
        setCookie('apiKey', apiKey, 7);
        messageElement.style.color = "#4CAF50";
        messageElement.textContent = "API key verified successfully!";
        messageElement.style.opacity = "1";

        setTimeout(() => {
            document.getElementById('apiKeyLogin').style.display = 'none';
            document.getElementById('chatInterface').style.display = 'flex';
            document.getElementById('settingsButton').style.display = 'block';
            loadChatHistory();
            updateChatList();
            showNotification('Welcome to Reddit Script Writer!');
        }, 1000);
    }

    function autoExpand(field) {
        field.style.height = 'auto';
        const maxHeight = parseInt(getComputedStyle(field).maxHeight, 10);
        const newHeight = Math.min(field.scrollHeight, maxHeight);
        field.style.height = newHeight + 'px';
        field.style.overflowY = field.scrollHeight > maxHeight ? 'auto' : 'hidden';
    }

    function setPrompt(prompt) {
        window.currentPrompt = prompt; // Store the prompt internally
    }

    function loadChatHistory() {
        const chatBox = document.getElementById("chatBox");
        chatBox.innerHTML = '<button onclick="toggleFullScreen()" id="fullScreenButton" class="full-screen-button">⛶</button>';
        const currentHistory = chatSessions[currentSessionId] || [];
        if (currentHistory.length === 0) {
            const welcomeBubble = document.createElement("div");
            welcomeBubble.className = "chat-bubble ai";
            welcomeBubble.textContent = "Hey! Add a Reddit story to get started—I'll turn it into a fresh script for you.";
            const wrapper = document.createElement("div");
            wrapper.className = "chat-bubble-wrapper ai";
            wrapper.appendChild(welcomeBubble);
            const copyButton = document.createElement("button");
            copyButton.className = "copy-button";
            copyButton.textContent = "📋";
            copyButton.title = "Copy to clipboard";
            copyButton.onclick = () => copyToClipboard(welcomeBubble.textContent);
            wrapper.appendChild(copyButton);
            chatBox.appendChild(wrapper);
        } else {
            currentHistory.forEach((msg, index) => {
                const bubble = document.createElement("div");
                bubble.className = `chat-bubble ${msg.role}`;
                bubble.textContent = msg.content;
                bubble.dataset.index = index;

                const wrapper = document.createElement("div");
                wrapper.className = `chat-bubble-wrapper ${msg.role}`;
                wrapper.appendChild(bubble);

                if (msg.role === 'assistant') {
                    const quoteButton = document.createElement("button");
                    quoteButton.className = "quote-button";
                    quoteButton.textContent = "💬";
                    quoteButton.title = "Quote this response";
                    quoteButton.onclick = () => quoteMessage(bubble);
                    wrapper.appendChild(quoteButton);

                    const retryButton = document.createElement("button");
                    retryButton.className = "retry-button";
                    retryButton.textContent = "🔄";
                    retryButton.title = "Regenerate response";
                    retryButton.onclick = () => retryMessage(bubble);
                    wrapper.appendChild(retryButton);

                    const copyButton = document.createElement("button");
                    copyButton.className = "copy-button";
                    copyButton.textContent = "📋";
                    copyButton.title = "Copy to clipboard";
                    copyButton.onclick = () => copyToClipboard(msg.content);
                    wrapper.appendChild(copyButton);
                } else if (msg.role === 'user') {
                    const editButton = document.createElement("button");
                    editButton.className = "edit-button";
                    editButton.textContent = "✏️";
                    editButton.title = "Edit this message";
                    editButton.onclick = () => startEditing(bubble);
                    wrapper.appendChild(editButton);
                }

                chatBox.appendChild(wrapper);
            });
        }
        chatBox.scrollTop = chatBox.scrollHeight;
    }

    function startEditing(bubble) {
        if (bubble.classList.contains('editable')) return;

        const wrapper = bubble.parentElement;
        const index = parseInt(bubble.dataset.index, 10);
        const originalText = bubble.textContent.trim();

        bubble.classList.add('editable');
        bubble.innerHTML = '';

        const textarea = document.createElement('textarea');
        textarea.value = originalText;
        textarea.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                finishEditing(bubble, wrapper, index, textarea.value);
            } else if (e.key === 'Escape') {
                cancelEditing(bubble, wrapper, originalText);
            }
        });
        textarea.addEventListener('input', () => autoExpand(textarea));
        bubble.appendChild(textarea);
        textarea.focus();
        autoExpand(textarea);

        wrapper.querySelector('.edit-button').style.display = 'none'; // Hide edit button during edit
    }
    
    async function finishEditing(bubble, wrapper, index, newText) {
        const chatBox = document.getElementById("chatBox");
        const sendButton = document.getElementById("sendStopButton");
        if (!chatBox || !sendButton) return;

        bubble.classList.remove('editable');
        bubble.innerHTML = '';
        bubble.textContent = newText;

        const editButton = wrapper.querySelector('.edit-button');
        editButton.style.display = 'block';

        const currentHistory = chatSessions[currentSessionId];
        currentHistory[index] = { role: 'user', content: newText };
        const newHistory = currentHistory.slice(0, index + 1);

        const allWrappers = Array.from(chatBox.querySelectorAll('.chat-bubble-wrapper'));
        const bubbleIndex = allWrappers.indexOf(wrapper);
        for (let i = allWrappers.length - 1; i > bubbleIndex; i--) {
            chatBox.removeChild(allWrappers[i]);
        }

        chatSessions[currentSessionId] = newHistory;
        setChatSessions(chatSessions);

        isRequestPending = true;
        sendButton.textContent = "■";
        sendButton.classList.add("active");

        const thinkingBubble = document.createElement("div");
        thinkingBubble.className = "chat-bubble ai placeholder";
        thinkingBubble.textContent = cookingMessages[Math.floor(Math.random() * cookingMessages.length)];
        const thinkingWrapper = document.createElement("div");
        thinkingWrapper.className = "chat-bubble-wrapper ai";
        thinkingWrapper.appendChild(thinkingBubble);
        chatBox.appendChild(thinkingWrapper);
        chatBox.scrollTop = chatBox.scrollHeight;

        abortController = new AbortController();
        try {
            const response = await fetch("/api/chat", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                signal: abortController.signal,
                body: JSON.stringify({ 
                    message: newText, 
                    apiKey: currentApiKey,
                    chatHistory: newHistory
                })
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.details || `HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            thinkingWrapper.remove();

            const aiBubble = document.createElement("div");
            aiBubble.className = "chat-bubble ai";
            aiBubble.textContent = data.response;
            const aiWrapper = document.createElement("div");
            aiWrapper.className = "chat-bubble-wrapper ai";
            aiWrapper.appendChild(aiBubble);

            const quoteButton = document.createElement("button");
            quoteButton.className = "quote-button";
            quoteButton.textContent = "💬";
            quoteButton.title = "Quote this response";
            quoteButton.onclick = () => quoteMessage(aiBubble);
            aiWrapper.appendChild(quoteButton);

            const retryButton = document.createElement("button");
            retryButton.className = "retry-button";
            retryButton.textContent = "🔄";
            retryButton.title = "Regenerate response";
            retryButton.onclick = () => retryMessage(aiBubble);
            aiWrapper.appendChild(retryButton);

            const copyButton = document.createElement("button");
            copyButton.className = "copy-button";
            copyButton.textContent = "📋";
            copyButton.title = "Copy to clipboard";
            copyButton.onclick = () => copyToClipboard(data.response);
            aiWrapper.appendChild(copyButton);

            chatBox.appendChild(aiWrapper);

            newHistory.push({ role: 'assistant', content: data.response });
            chatSessions[currentSessionId] = newHistory;
            setChatSessions(chatSessions);

            updateChatList();
            chatBox.scrollTop = chatBox.scrollHeight;
        } catch (error) {
            if (error.name !== 'AbortError') {
                thinkingWrapper.remove();
                const errorBubble = document.createElement("div");
                errorBubble.className = "chat-bubble ai";
                errorBubble.textContent = `Error: ${error.message}`;
                const errorWrapper = document.createElement("div");
                errorWrapper.className = "chat-bubble-wrapper ai";
                errorWrapper.appendChild(errorBubble);

                const quoteButton = document.createElement("button");
                quoteButton.className = "quote-button";
                quoteButton.textContent = "💬";
                quoteButton.title = "Quote this response";
                quoteButton.onclick = () => quoteMessage(errorBubble);
                errorWrapper.appendChild(quoteButton);

                const retryButton = document.createElement("button");
                retryButton.className = "retry-button";
                retryButton.textContent = "🔄";
                retryButton.title = "Regenerate response";
                retryButton.onclick = () => retryMessage(errorBubble);
                errorWrapper.appendChild(retryButton);

                const copyButton = document.createElement("button");
                copyButton.className = "copy-button";
                copyButton.textContent = "📋";
                copyButton.title = "Copy to clipboard";
                copyButton.onclick = () => copyToClipboard(errorBubble.textContent);
                errorWrapper.appendChild(copyButton);

                chatBox.appendChild(errorWrapper);
                chatBox.scrollTop = chatBox.scrollHeight;
                
                showNotification(`Error: ${error.message}`, 'error');
            } else {
                thinkingWrapper.remove();
            }
        } finally {
            isRequestPending = false;
            sendButton.textContent = "➤";
            sendButton.classList.remove("active");
        }
    }

    function cancelEditing(bubble, wrapper, originalText) {
        bubble.classList.remove('editable');
        bubble.textContent = originalText;
        wrapper.querySelector('.edit-button').style.display = 'block';
    }

    function updateChatList() {
        const chatList = document.getElementById("chatList");
        chatList.innerHTML = '';
        
        sessionNames = getSavedSessionNames();
        
        const currentChatIndicator = document.getElementById("currentChatIndicator");
        const currentChatName = sessionNames[currentSessionId] || "New Chat";
        currentChatIndicator.textContent = currentChatName;
        
        Object.keys(chatSessions).forEach(sessionId => {
            const chatItem = document.createElement("div");
            chatItem.className = "chat-actions";
            
            const button = document.createElement("button");
            button.className = "side-button";
            if (sessionId === currentSessionId) {
                button.classList.add("current");
            }
            
            let sessionName = sessionNames[sessionId];
            if (!sessionName) {
                const chatNumber = Object.keys(sessionNames).length + 1;
                sessionName = `Chat ${chatNumber}`;
                sessionNames[sessionId] = sessionName;
                setCookie('sessionNames', JSON.stringify(sessionNames), 7);
            }
            
            button.textContent = sessionName;
            button.style.width = "85%";
            button.onclick = () => switchChat(sessionId);
            
            const deleteButton = document.createElement("button");
            deleteButton.className = "delete-chat";
            deleteButton.textContent = "×";
            deleteButton.title = "Delete chat";
            deleteButton.onclick = (e) => deleteChat(sessionId, e);
            
            chatItem.appendChild(button);
            chatItem.appendChild(deleteButton);
            
            chatList.appendChild(chatItem);
        });
    }

    function newChat() {
        currentSessionId = Date.now().toString();
        chatSessions[currentSessionId] = [];
        const chatNumber = Object.keys(chatSessions).length;
        sessionNames[currentSessionId] = `Chat ${chatNumber}`;
        setChatSessions(chatSessions);
        setCookie('sessionNames', JSON.stringify(sessionNames), 7);
        loadChatHistory();
        updateChatList();
        hideSidebar();
        showNotification('New chat created!');
    }

    function switchChat(sessionId) {
        if (!chatSessions[sessionId]) {
            console.error("Session not found:", sessionId);
            return;
        }
        
        currentSessionId = sessionId;
        
        const currentChatIndicator = document.getElementById("currentChatIndicator");
        if (currentChatIndicator) {
            const currentChatName = sessionNames[sessionId] || "New Chat";
            currentChatIndicator.textContent = currentChatName;
        }
        
        loadChatHistory();
        updateChatList();
        hideSidebar();
    }

    function toggleSideExtension() {
        const sideExtension = document.getElementById("sideExtension");
        
        if (sideExtension.classList.contains("active")) {
            sideExtension.classList.remove("active");
            sideExtension.classList.remove("edge-only");
        } else {
            sideExtension.classList.add("active");
            sideExtension.classList.remove("edge-only");
        }
    }
    
    function hideSidebar() {
        const sideExtension = document.getElementById("sideExtension");
        sideExtension.classList.remove("active");
        sideExtension.classList.remove("edge-only");
    }
    
    function deleteChat(sessionId, event) {
        event.stopPropagation();
        
        if (confirm("Are you sure you want to delete this chat?")) {
            delete chatSessions[sessionId];
            delete sessionNames[sessionId];
            setChatSessions(chatSessions);
            setCookie('sessionNames', JSON.stringify(sessionNames), 7);
            
            if (sessionId === currentSessionId) {
                const remainingSessions = Object.keys(chatSessions);
                if (remainingSessions.length > 0) {
                    currentSessionId = remainingSessions[0];
                } else {
                    currentSessionId = Date.now().toString();
                    chatSessions[currentSessionId] = [];
                    sessionNames[currentSessionId] = `Chat 1`;
                    setChatSessions(chatSessions);
                    setCookie('sessionNames', JSON.stringify(sessionNames), 7);
                }
                loadChatHistory();
            }
            
            updateChatList();
            showNotification('Chat deleted');
        }
    }

    function toggleSendStop() {
        if (isRequestPending) {
            if (abortController) {
                abortController.abort();
                isRequestPending = false;
                const sendButton = document.getElementById("sendStopButton");
                sendButton.textContent = "➤";
                sendButton.classList.remove("active");
                const chatBox = document.getElementById("chatBox");
                const thinkingBubble = chatBox.querySelector(".chat-bubble.ai.placeholder");
                if (thinkingBubble) thinkingBubble.parentElement.remove();
                showNotification('Request canceled');
            }
        } else {
            sendMessage();
        }
    }

    // Notification function - creates a temporary notification
    function showNotification(message, type = 'success') {
        // Remove any existing notifications
        const existingNotification = document.querySelector('.success-notification');
        if (existingNotification) {
            existingNotification.remove();
        }
        
        // Create notification element
        const notification = document.createElement('div');
        notification.className = 'success-notification';
        notification.textContent = message;
        
        if (type === 'error') {
            notification.style.background = 'linear-gradient(135deg, #FF5555, #CC4444)';
            notification.classList.add('error-notification');
        }
        
        // Add to body
        document.body.appendChild(notification);
        
        // Remove after animation completes
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        }, 3000);
    }
    
    // Save Script - improved with proper script extraction
    async function saveScript() {
        const currentHistory = chatSessions[currentSessionId] || [];
        
        if (currentHistory.length === 0) {
            showNotification('No script found to save! Please generate a script first.', 'error');
            return;
        }
        
        // Find the most recent AI message that contains a script
        let scriptContent = null;
        let scriptIndex = -1;
        
        for (let i = currentHistory.length - 1; i >= 0; i--) {
            const msg = currentHistory[i];
            if (msg.role === 'assistant') {
                scriptContent = msg.content;
                scriptIndex = i;
                break;
            }
        }
        
        if (scriptIndex === -1) {
            showNotification('No script found to save! Please generate a script first.', 'error');
            return;
        }
        
        // Validate script contains proper markers
        if (!scriptContent.includes("=== SCRIPT START ===") || !scriptContent.includes("=== SCRIPT END ===")) {
            showNotification('The last message does not contain a valid script with START and END markers.', 'error');
            return;
        }
        
        // Extract just the script part between the markers
        const scriptMatch = scriptContent.match(/=== SCRIPT START ===\n([\s\S]*?)\n=== SCRIPT END ===/);
        if (!scriptMatch || !scriptMatch[1]) {
            showNotification('Could not extract script content properly.', 'error');
            return;
        }
        
        const extractedScript = scriptMatch[1].trim();
        
        // Check for duplicate script in the saved scripts
        try {
            const savedScripts = await fetchSavedScripts();
            const isDuplicate = savedScripts.some(script => script.content.trim() === extractedScript);
            
            if (isDuplicate) {
                showNotification('This script has already been saved! Please generate a new script.', 'error');
                return;
            }
            
            // If all validation passes, save the script
            saveScriptToServer(scriptContent);
        } catch (error) {
            console.error('Error checking for duplicate scripts:', error);
            showNotification('Error verifying script uniqueness. Please try again.', 'error');
        }
    }
    
    // Direct save to server function
    async function saveScriptToServer(scriptContent) {
        try {
            // Extract just the script part between the markers
            const scriptMatch = scriptContent.match(/=== SCRIPT START ===\n([\s\S]*?)\n=== SCRIPT END ===/);
            if (!scriptMatch || !scriptMatch[1]) {
                throw new Error('Could not extract script content');
            }
            
            const extractedScript = scriptMatch[1].trim();
            
            // Create loading indicator
            const chatBox = document.getElementById("chatBox");
            const loadingBubble = document.createElement("div");
            loadingBubble.className = "chat-bubble ai placeholder";
            loadingBubble.textContent = "Saving script...";
            const loadingWrapper = document.createElement("div");
            loadingWrapper.className = "chat-bubble-wrapper ai";
            loadingWrapper.appendChild(loadingBubble);
            chatBox.appendChild(loadingWrapper);
            chatBox.scrollTop = chatBox.scrollHeight;
            
            // Send the script to the server for saving
            const response = await fetch('/api/save-script', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ 
                    scriptContent: extractedScript,
                    timestamp: new Date().toISOString()
                })
            });
            
            // Remove the loading indicator
            loadingWrapper.remove();
            
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || `Server error: ${response.status}`);
            }
            
            // Add success message
            const successBubble = document.createElement("div");
            successBubble.className = "chat-bubble ai";
            successBubble.textContent = "Script saved successfully! You can view it in the Settings menu.";
            const successWrapper = document.createElement("div");
            successWrapper.className = "chat-bubble-wrapper ai";
            successWrapper.appendChild(successBubble);
            
            // Add action buttons to the success message
            const quoteButton = document.createElement("button");
            quoteButton.className = "quote-button";
            quoteButton.textContent = "💬";
            quoteButton.title = "Quote this response";
            quoteButton.onclick = () => quoteMessage(successBubble);
            successWrapper.appendChild(quoteButton);
            
            const copyButton = document.createElement("button");
            copyButton.className = "copy-button";
            copyButton.textContent = "📋";
            copyButton.title = "Copy to clipboard";
            copyButton.onclick = () => copyToClipboard(successBubble.textContent);
            successWrapper.appendChild(copyButton);
            
            chatBox.appendChild(successWrapper);
            chatBox.scrollTop = chatBox.scrollHeight;
            
            // Update chat history
            const currentHistory = chatSessions[currentSessionId];
            currentHistory.push({ role: 'assistant', content: "Script saved successfully! You can view it in the Settings menu." });
            chatSessions[currentSessionId] = currentHistory;
            setChatSessions(chatSessions);
            
            // Show a floating notification
            showNotification('Script saved successfully!');
            
        } catch (error) {
            console.error('Error saving script:', error);
            
            // Show error message
            const chatBox = document.getElementById("chatBox");
            const errorBubble = document.createElement("div");
            errorBubble.className = "chat-bubble ai";
            errorBubble.textContent = `Error saving script: ${error.message}`;
            const errorWrapper = document.createElement("div");
            errorWrapper.className = "chat-bubble-wrapper ai";
            errorWrapper.appendChild(errorBubble);
            
            const retryButton = document.createElement("button");
            retryButton.className = "retry-button";
            retryButton.textContent = "🔄";
            retryButton.title = "Try again";
            retryButton.onclick = () => saveScript();
            errorWrapper.appendChild(retryButton);
            
            chatBox.appendChild(errorWrapper);
            chatBox.scrollTop = chatBox.scrollHeight;
            
            // Show notification
            showNotification(`Error saving script: ${error.message}`, 'error');
        }
    }

    // Improved copy to clipboard with notification
    function copyToClipboard(text) {
        navigator.clipboard.writeText(text).then(() => {
            showNotification('Copied to clipboard!');
        }).catch(err => {
            console.error('Failed to copy:', err);
            showNotification('Failed to copy to clipboard', 'error');
        });
    }

    async function sendMessage() {
        if (isRequestPending) {
            return; // Silently prevent sending
        }

        const userInput = document.getElementById("userInput");
        const chatBox = document.getElementById("chatBox");
        const sendButton = document.getElementById("sendStopButton");
        const message = userInput.value.trim();

        if (!message && !window.currentPrompt) return; // Require either a message or a pre-set prompt
        if (!currentApiKey) return;

        isRequestPending = true;
        sendButton.textContent = "■";
        sendButton.classList.add("active");

        const currentHistory = chatSessions[currentSessionId] || [];
        let editedBubble = chatBox.querySelector('.chat-bubble.editable');
        let editedIndex = editedBubble ? parseInt(editedBubble.dataset.index, 10) : -1;

        // Determine what to display in the user bubble - FIXED to show full content
        let displayMessage = message;
        let messageToSend = message;
        
        if (!message && window.currentPrompt) {
            displayMessage = window.currentPrompt; // Show full prompt instead of a placeholder
            messageToSend = window.currentPrompt;
        }

        if (editedIndex !== -1) {
            editedBubble.textContent = displayMessage;
            editedBubble.classList.remove('editable');
            const wrapper = editedBubble.parentElement;
            wrapper.innerHTML = ''; // Clear wrapper
            wrapper.appendChild(editedBubble);
            const editButton = document.createElement("button");
            editButton.className = "edit-button";
            editButton.textContent = "✏️";
            editButton.title = "Edit this message";
            editButton.onclick = () => startEditing(editedBubble);
            wrapper.appendChild(editButton);
        } else {
            const userBubble = document.createElement("div");
            userBubble.className = "chat-bubble user";
            userBubble.textContent = displayMessage;
            userBubble.dataset.index = currentHistory.length;

            const wrapper = document.createElement("div");
            wrapper.className = "chat-bubble-wrapper user";
            wrapper.appendChild(userBubble);

            const editButton = document.createElement("button");
            editButton.className = "edit-button";
            editButton.textContent = "✏️";
            editButton.title = "Edit this message";
            editButton.onclick = () => startEditing(userBubble);
            wrapper.appendChild(editButton);

            chatBox.appendChild(wrapper);
        }

        const thinkingBubble = document.createElement("div");
        thinkingBubble.className = "chat-bubble ai placeholder";
        thinkingBubble.textContent = cookingMessages[Math.floor(Math.random() * cookingMessages.length)];
        const thinkingWrapper = document.createElement("div");
        thinkingWrapper.className = "chat-bubble-wrapper ai";
        thinkingWrapper.appendChild(thinkingBubble);
        chatBox.appendChild(thinkingWrapper);

        userInput.value = "";
        autoExpand(userInput);
        chatBox.scrollTop = chatBox.scrollHeight;

        abortController = new AbortController();
        try {
            if (editedIndex !== -1) {
                currentHistory[editedIndex] = { role: 'user', content: displayMessage };
                currentHistory.splice(editedIndex + 1);
            } else {
                currentHistory.push({ role: 'user', content: displayMessage });
            }

            const response = await fetch("/api/chat", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                signal: abortController.signal,
                body: JSON.stringify({ 
                    message: messageToSend, 
                    apiKey: currentApiKey,
                    chatHistory: currentHistory
                })
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.details || `HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            thinkingWrapper.remove();

            const aiBubble = document.createElement("div");
            aiBubble.className = "chat-bubble ai";
            aiBubble.textContent = data.response;
            const aiWrapper = document.createElement("div");
            aiWrapper.className = "chat-bubble-wrapper ai";
            aiWrapper.appendChild(aiBubble);

            const quoteButton = document.createElement("button");
            quoteButton.className = "quote-button";
            quoteButton.textContent = "💬";
            quoteButton.title = "Quote this response";
            quoteButton.onclick = () => quoteMessage(aiBubble);
            aiWrapper.appendChild(quoteButton);

            const retryButton = document.createElement("button");
            retryButton.className = "retry-button";
            retryButton.textContent = "🔄";
            retryButton.title = "Regenerate response";
            retryButton.onclick = () => retryMessage(aiBubble);
            aiWrapper.appendChild(retryButton);

            const copyButton = document.createElement("button");
            copyButton.className = "copy-button";
            copyButton.textContent = "📋";
            copyButton.title = "Copy to clipboard";
            copyButton.onclick = () => copyToClipboard(data.response);
            aiWrapper.appendChild(copyButton);

            chatBox.appendChild(aiWrapper);

            currentHistory.push({ role: 'assistant', content: data.response });
            chatSessions[currentSessionId] = currentHistory;
            setChatSessions(chatSessions);

            updateChatList();
            chatBox.scrollTop = chatBox.scrollHeight;

            // Reset window.currentPrompt after use to prevent reuse
            window.currentPrompt = null;
            currentStory = ''; // Clear stored story
            currentTranscript = ''; // Clear stored transcript
        } catch (error) {
            if (error.name !== 'AbortError') {
                thinkingWrapper.remove();
                const errorBubble = document.createElement("div");
                errorBubble.className = "chat-bubble ai";
                errorBubble.textContent = `Error: ${error.message}`;
                const errorWrapper = document.createElement("div");
                errorWrapper.className = "chat-bubble-wrapper ai";
                errorWrapper.appendChild(errorBubble);

                const quoteButton = document.createElement("button");
                quoteButton.className = "quote-button";
                quoteButton.textContent = "💬";
                quoteButton.title = "Quote this response";
                quoteButton.onclick = () => quoteMessage(errorBubble);
                errorWrapper.appendChild(quoteButton);

                const retryButton = document.createElement("button");
                retryButton.className = "retry-button";
                retryButton.textContent = "🔄";
                retryButton.title = "Regenerate response";
                retryButton.onclick = () => retryMessage(errorBubble);
                errorWrapper.appendChild(retryButton);

                const copyButton = document.createElement("button");
                copyButton.className = "copy-button";
                copyButton.textContent = "📋";
                copyButton.title = "Copy to clipboard";
                copyButton.onclick = () => copyToClipboard(errorBubble.textContent);
                errorWrapper.appendChild(copyButton);

                chatBox.appendChild(errorWrapper);
                chatBox.scrollTop = chatBox.scrollHeight;
                
                showNotification(`Error: ${error.message}`, 'error');
            } else {
                thinkingWrapper.remove();
            }
        } finally {
            isRequestPending = false;
            sendButton.textContent = "➤";
            sendButton.classList.remove("active");
            userInput.value = ""; // Redundant clear to ensure input is empty
            autoExpand(userInput);
        }
    }

    async function retryMessage(aiBubble) {
        if (isRequestPending) return;

        const chatBox = document.getElementById("chatBox");
        const sendButton = document.getElementById("sendStopButton");
        const wrapper = aiBubble.parentElement;
        const allWrappers = Array.from(chatBox.querySelectorAll('.chat-bubble-wrapper'));
        const aiIndex = allWrappers.indexOf(wrapper);

        let userWrapper = allWrappers[aiIndex - 1];
        if (!userWrapper || !userWrapper.classList.contains('user')) {
            showNotification("No preceding user message found to regenerate.", "error");
            return;
        }

        const prompt = userWrapper.querySelector('.chat-bubble').textContent;
        const currentHistory = chatSessions[currentSessionId];
        const promptIndex = currentHistory.findIndex(msg => msg.role === 'user' && msg.content === prompt);
        if (promptIndex === -1) {
            showNotification("Prompt not found in chat history.", "error");
            return;
        }

        const newHistory = currentHistory.slice(0, promptIndex + 1);
        chatSessions[currentSessionId] = newHistory;
        setChatSessions(chatSessions);

        for (let i = allWrappers.length - 1; i > promptIndex; i--) {
            chatBox.removeChild(allWrappers[i]);
        }

        isRequestPending = true;
        sendButton.textContent = "■";
        sendButton.classList.add("active");

        const thinkingBubble = document.createElement("div");
        thinkingBubble.className = "chat-bubble ai placeholder";
        thinkingBubble.textContent = cookingMessages[Math.floor(Math.random() * cookingMessages.length)];
        const thinkingWrapper = document.createElement("div");
        thinkingWrapper.className = "chat-bubble-wrapper ai";
        thinkingWrapper.appendChild(thinkingBubble);
        chatBox.appendChild(thinkingWrapper);
        chatBox.scrollTop = chatBox.scrollHeight;

        abortController = new AbortController();
        try {
            const response = await fetch("/api/chat", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                signal: abortController.signal,
                body: JSON.stringify({ 
                    message: prompt, 
                    apiKey: currentApiKey,
                    chatHistory: newHistory,
                    isRetry: true
                })
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.details || `HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            thinkingWrapper.remove();

            const newAiBubble = document.createElement("div");
            newAiBubble.className = "chat-bubble ai";
            newAiBubble.textContent = data.response;
            const newAiWrapper = document.createElement("div");
            newAiWrapper.className = "chat-bubble-wrapper ai";
            newAiWrapper.appendChild(newAiBubble);

            const quoteButton = document.createElement("button");
            quoteButton.className = "quote-button";
            quoteButton.textContent = "💬";
            quoteButton.title = "Quote this response";
            quoteButton.onclick = () => quoteMessage(newAiBubble);
            newAiWrapper.appendChild(quoteButton);

            const retryButton = document.createElement("button");
            retryButton.className = "retry-button";
            retryButton.textContent = "🔄";
            retryButton.title = "Regenerate response";
            retryButton.onclick = () => retryMessage(newAiBubble);
            newAiWrapper.appendChild(retryButton);

            const copyButton = document.createElement("button");
            copyButton.className = "copy-button";
            copyButton.textContent = "📋";
            copyButton.title = "Copy to clipboard";
            copyButton.onclick = () => copyToClipboard(data.response);
            newAiWrapper.appendChild(copyButton);

            chatBox.appendChild(newAiWrapper);

            newHistory.push({ role: 'assistant', content: data.response });
            chatSessions[currentSessionId] = newHistory;
            setChatSessions(chatSessions);

            updateChatList();
            chatBox.scrollTop = chatBox.scrollHeight;
            
            showNotification("Response regenerated!");
        } catch (error) {
            if (error.name !== 'AbortError') {
                thinkingWrapper.remove();
                const errorBubble = document.createElement("div");
                errorBubble.className = "chat-bubble ai";
                errorBubble.textContent = `Error: ${error.message}`;
                const errorWrapper = document.createElement("div");
                errorWrapper.className = "chat-bubble-wrapper ai";
                errorWrapper.appendChild(errorBubble);

                const quoteButton = document.createElement("button");
                quoteButton.className = "quote-button";
                quoteButton.textContent = "💬";
                quoteButton.title = "Quote this response";
                quoteButton.onclick = () => quoteMessage(errorBubble);
                errorWrapper.appendChild(quoteButton);

                const retryButton = document.createElement("button");
                retryButton.className = "retry-button";
                retryButton.textContent = "🔄";
                retryButton.title = "Regenerate response";
                retryButton.onclick = () => retryMessage(errorBubble);
                errorWrapper.appendChild(retryButton);

                const copyButton = document.createElement("button");
                copyButton.className = "copy-button";
                copyButton.textContent = "📋";
                copyButton.title = "Copy to clipboard";
                copyButton.onclick = () => copyToClipboard(errorBubble.textContent);
                errorWrapper.appendChild(copyButton);

                chatBox.appendChild(errorWrapper);
                chatBox.scrollTop = chatBox.scrollHeight;
                
                showNotification(`Error: ${error.message}`, 'error');
            } else {
                thinkingWrapper.remove();
            }
        } finally {
            isRequestPending = false;
            sendButton.textContent = "➤";
            sendButton.classList.remove("active");
        }
    }

    function quoteMessage(aiBubble) {
        const selection = window.getSelection().toString().trim();
        const textToQuote = selection || aiBubble.textContent;
        const userInput = document.getElementById("userInput");
        userInput.value = `> ${textToQuote}\n\n`;
        autoExpand(userInput);
        userInput.focus();
    }
    
    function toggleSettings() {
        const menu = document.getElementById('settingsMenu');
        menu.classList.toggle('active');
    }

    function showKeys() {
        document.getElementById('accessKeyDisplay').textContent = currentAccessKey || 'Not set';
        document.getElementById('apiKeyDisplay').textContent = currentApiKey || 'Not set';
        showModal('keysModal');
        document.getElementById('settingsMenu').classList.remove('active');
    }

    function showSavedScripts() {
        document.getElementById('settingsMenu').classList.remove('active');
        const modal = document.getElementById('savedScriptsModal');
        const list = document.getElementById('savedScriptsList');
        list.innerHTML = 'Loading...';
        showModal('savedScriptsModal');

        fetchSavedScripts().then(scripts => {
            list.innerHTML = '';
            if (!scripts || scripts.length === 0) {
                list.textContent = 'No saved scripts yet!';
                return;
            }
            scripts.forEach((script, index) => {
                const scriptDiv = document.createElement('div');
                scriptDiv.className = 'saved-script';
                scriptDiv.style.display = 'flex';
                scriptDiv.style.alignItems = 'center';

                const scriptText = document.createElement('span');
                scriptText.textContent = script.content;
                scriptText.style.flexGrow = '1';
                scriptDiv.appendChild(scriptText);

                const deleteButton = document.createElement("button");
                deleteButton.className = "saved-script-delete-button";
                deleteButton.textContent = "Delete";
                deleteButton.onclick = () => deleteSavedScript(script.timestamp);
                scriptDiv.appendChild(deleteButton);

                list.appendChild(scriptDiv);
                if (index < scripts.length - 1) {
                    const separator = document.createElement('div');
                    separator.className = 'script-separator';
                    list.appendChild(separator);
                }
            });
        });
    }
    
    async function deleteSavedScript(timestamp) {
        if (confirm("Are you sure you want to delete this script?")) {
            try {
                showLoading();
                const response = await fetch('/api/delete-saved-script', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ timestamp })
                });
                hideLoading();
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Failed to delete script');
                }
                showSavedScripts(); // Refresh the list
                showNotification('Script deleted successfully!');
            } catch (error) {
                hideLoading();
                console.error('Error deleting script:', error);
                showNotification(`Failed to delete script: ${error.message}`, 'error');
            }
        }
    }
    
    async function clearSavedScripts() {
        if (confirm('Are you sure you want to clear all saved scripts?')) {
            try {
                const list = document.getElementById('savedScriptsList');
                list.innerHTML = 'Clearing scripts...';
                
                showLoading();
                const response = await fetch('/api/clear-saved-scripts', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                hideLoading();
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Failed to clear scripts');
                }
                
                const result = await response.json();
                console.log('Clear scripts result:', result);
                
                list.textContent = 'No saved scripts yet!';
                
                showNotification('Scripts cleared successfully!');
            } catch (error) {
                hideLoading();
                console.error('Error clearing saved scripts:', error);
                showNotification(`Failed to clear scripts: ${error.message}`, 'error');
            }
        }
    }

    function downloadScripts() {
        fetchSavedScripts().then(scripts => {
            if (scripts.length === 0) {
                showNotification('No scripts to download!', 'error');
                return;
            }
            const content = scripts.map(s => s.content).join('\n\n---\n\n');
            const blob = new Blob([content], { type: 'text/plain' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'saved_scripts.txt';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
            showNotification('Scripts downloaded!');
        });
    }
    
    function toggleTheme() {
        const body = document.body;
        const themeToggle = document.getElementById('themeToggle');
        const currentTheme = body.getAttribute('data-theme');
        
        body.setAttribute('data-theme-transitioning', 'true');
        
        if (currentTheme === 'light') {
            body.removeAttribute('data-theme');
            themeToggle.textContent = '☀️ To Light';
            setCookie('theme', 'dark', 7);
        } else {
            body.setAttribute('data-theme', 'light');
            themeToggle.textContent = '🌙 To Dark';
            setCookie('theme', 'light', 7);
        }
        
        // Remove transitioning class after animation completes
        setTimeout(() => {
            body.removeAttribute('data-theme-transitioning');
        }, 500);
        
        document.getElementById('settingsMenu').classList.remove('active');
        showNotification(`Theme switched to ${currentTheme === 'light' ? 'dark' : 'light'} mode`);
    }

    function toggleFullScreen() {
        const chatContainer = document.getElementById('chatInterface');
        chatContainer.classList.toggle('full-screen');
        
        if (chatContainer.classList.contains('full-screen')) {
            document.documentElement.style.overflow = 'hidden';
            showNotification('Fullscreen mode enabled');
        } else {
            document.documentElement.style.overflow = '';
            showNotification('Fullscreen mode disabled');
        }
    }
    
    function logout() {
        if (confirm('Are you sure you want to log out?')) {
            currentAccessKey = '';
            currentApiKey = '';
            currentSessionId = Date.now().toString();
            chatSessions[currentSessionId] = [];
            sessionNames[currentSessionId] = `Script #1`;
            setChatSessions(chatSessions);
            setCookie('sessionNames', JSON.stringify(sessionNames), 7);
            
            deleteCookie('accessKey');
            deleteCookie('apiKey');
            
            document.getElementById('accessKey').value = '';
            document.getElementById('apiKey').value = '';
            
            document.getElementById('accessKeyMessage').style.opacity = '0';
            document.getElementById('apiKeyMessage').style.opacity = '0';
            
            document.getElementById('chatInterface').style.display = 'none';
            document.getElementById('settingsMenu').classList.remove('active');
            document.getElementById('settingsButton').style.display = 'none';
            
            document.getElementById('accessKeyLogin').style.display = 'flex';
            
            document.getElementById('chatBox').innerHTML = '';
            
            showNotification('Logged out successfully');
        }
    }

    // Full page loading animation
    function showLoading() {
        const loader = document.createElement('div');
        loader.className = 'full-page-loader';
        loader.innerHTML = `
            <div class="loader-content">
                <div class="spinner"></div>
                <div class="loader-text">Loading...</div>
            </div>
        `;
        document.body.appendChild(loader);
    }

    function hideLoading() {
        const loader = document.querySelector('.full-page-loader');
        if (loader) {
            loader.classList.add('fade-out');
            setTimeout(() => {
                if (loader.parentNode) {
                    loader.parentNode.removeChild(loader);
                }
            }, 500);
        }
    }

    // Enhanced animation helpers
    document.addEventListener("DOMContentLoaded", function() {
        const savedAccessKey = getCookie('accessKey');
        const savedApiKey = getCookie('apiKey');
        const savedTheme = getCookie('theme');
        const themeToggle = document.getElementById('themeToggle');
        
        if (savedTheme === 'light') {
            document.body.setAttribute('data-theme', 'light');
            themeToggle.textContent = '🌙 To Dark';
        } else {
            document.body.removeAttribute('data-theme');
            themeToggle.textContent = '☀️ To Light';
        }

        if (savedAccessKey && savedApiKey) {
            currentAccessKey = savedAccessKey;
            currentApiKey = savedApiKey;
            document.getElementById('accessKeyLogin').style.display = 'none';
            document.getElementById('apiKeyLogin').style.display = 'none';
            document.getElementById('chatInterface').style.display = 'flex';
            document.getElementById('settingsButton').style.display = 'block';
            
            const sideExtension = document.getElementById("sideExtension");
            sideExtension.classList.remove("active");
            sideExtension.classList.remove("edge-only");
            
            loadChatHistory();
            updateChatList();
        }

        const accessKeyInput = document.getElementById('accessKey');
        const apiKeyInput = document.getElementById('apiKey');
        const userInput = document.getElementById("userInput");
        const ytLinkInput = document.getElementById("ytLinkInput");

        accessKeyInput.addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                verifyAccessKey();
            }
        });

        apiKeyInput.addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                verifyApiKey();
            }
        });

        userInput.addEventListener("keypress", function(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        });
        
        if (ytLinkInput) {
            ytLinkInput.addEventListener('keypress', function(event) {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    submitYtLink();
                }
            });
        }

        // Add animation classes to elements when they come into view
        const animateOnScroll = () => {
            const elements = document.querySelectorAll('.animate-on-scroll:not(.animated)');
            elements.forEach(element => {
                const elementTop = element.getBoundingClientRect().top;
                const elementVisible = 150;
                if (elementTop < window.innerHeight - elementVisible) {
                    element.classList.add('animated');
                }
            });
        };
        
        // Initial check and scroll listener
        animateOnScroll();
        window.addEventListener('scroll', animateOnScroll);
        
        // Add animation classes to chat-bubble elements
        const chatBox = document.getElementById('chatBox');
        if (chatBox) {
            const observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    if (mutation.addedNodes.length) {
                        mutation.addedNodes.forEach((node) => {
                            if (node.classList && node.classList.contains('chat-bubble-wrapper')) {
                                node.classList.add('animate-in');
                                setTimeout(() => {
                                    node.classList.remove('animate-in');
                                }, 500);
                            }
                        });
                    }
                });
            });
            
            observer.observe(chatBox, { childList: true });
        }

        document.addEventListener('click', function(event) {
            const settingsMenu = document.getElementById('settingsMenu');
            const settingsButton = document.getElementById('settingsButton');
            const sideExtension = document.getElementById('sideExtension');
            const sidebarToggle = document.getElementById('sidebarToggle');
            
            if (settingsMenu && settingsButton && !settingsButton.contains(event.target) && !settingsMenu.contains(event.target)) {
                settingsMenu.classList.remove('active');
            }
            
            if (sideExtension && sideExtension.classList.contains('active') && 
                sidebarToggle && !sideExtension.contains(event.target) && 
                !sidebarToggle.contains(event.target)) {
                hideSidebar();
            }
            
            // Close any modal when clicking outside
            const activeModal = document.querySelector('.modal.active');
            if (activeModal && event.target === activeModal) {
                closeModal(activeModal.id);
            }
        });

        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                const chatContainer = document.getElementById('chatInterface');
                if (chatContainer.classList.contains('full-screen')) {
                    chatContainer.classList.remove('full-screen');
                    document.documentElement.style.overflow = '';
                }
                
                // Close any active modal
                const activeModal = document.querySelector('.modal.active');
                if (activeModal) {
                    closeModal(activeModal.id);
                }
                
                // Close settings menu
                const settingsMenu = document.getElementById('settingsMenu');
                if (settingsMenu && settingsMenu.classList.contains('active')) {
                    settingsMenu.classList.remove('active');
                }
            }
        });

        autoExpand(userInput);
        setupMobileOptimizations();
    });
    
    // Improved mobile experience
    function setupMobileOptimizations() {
        const isMobile = window.innerWidth < 768;
        
        if (isMobile) {
            // Add touch-specific classes
            document.body.classList.add('mobile-device');
            
            // Adjust text areas for better mobile typing
            const textareas = document.querySelectorAll('textarea');
            textareas.forEach(textarea => {
                textarea.addEventListener('focus', () => {
                    // Scroll the page after a short delay to ensure the textarea is visible
                    setTimeout(() => {
                        textarea.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }, 300);
                });
            });
        } else {
            document.body.classList.remove('mobile-device');
        }
    }

    // Initialize mobile optimizations
    window.addEventListener('resize', setupMobileOptimizations);
    </script>
</body>
</html>