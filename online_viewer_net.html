<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reddit Script Writer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600&display=swap" rel="stylesheet">
<style>
    :root {
        --primary: #368CFF;
        --secondary: #1F2A44;
        --background: #0A0A0A;
        --text: #E0E0E0;
        --bubble-user: #368CFF;
        --bubble-ai: #2A2F4A;
        --border-radius: 20px;
        --shadow: 0px 6px 24px rgba(0, 0, 0, 0.5);
        --side-bg: #1A1A2E;
        --highlight: #3A3F5A;
    }

    [data-theme="light"] {
        --primary: #368CFF;
        --secondary: #E6F0FA;
        --background: #F5F7FA;
        --text: #2E2E2E;
        --bubble-user: #368CFF;
        --bubble-ai: #DDE4EA;
        --shadow: 0px 6px 24px rgba(0, 0, 0, 0.15);
        --side-bg: #E0E6ED;
        --highlight: #B3C8E6;
    }
    
    [data-theme-transitioning] {
        transition: color 0.5s ease, background-color 0.5s ease;
    }
    
    body {
        background-color: var(--background);
        color: var(--text);
        font-family: 'Space Grotesk', sans-serif;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        margin: 0;
        padding: 1rem;
        position: relative;
        transition: background-color 0.3s ease, color 0.3s ease;
        overflow: hidden;
    }

    #bgGif {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        z-index: -1;
        margin: 0;
        padding: 0;
        border: none;
        pointer-events: none;
    }

    .chat-bubble-wrapper {
        display: flex;
        align-items: center;
        width: 100%;
    }

    .chat-bubble-wrapper.user {
        justify-content: flex-end; /* Bubble on right */
    }

    .chat-bubble-wrapper.ai {
        justify-content: flex-start; /* Bubble on left */
    }

    .chat-bubble {
        padding: 16px 20px;
        border-radius: var(--border-radius);
        max-width: 75%;
        font-size: 16px;
        line-height: 1.5;
        box-shadow: var(--shadow);
        word-wrap: break-word;
        white-space: pre-wrap;
        background: linear-gradient(135deg, var(--bubble-ai), var(--secondary));
        transition: background 0.3s ease, color 0.3s ease, transform 0.3s ease, box-shadow 0.3s ease;
        transform: perspective(500px) translateZ(10px);
        animation: slideUp 0.4s cubic-bezier(0.22, 0.61, 0.36, 1);
    }

    .chat-bubble:hover {
            transform: none !important;
            box-shadow: var(--shadow) !important;
    }

    .chat-bubble.user {
        background: linear-gradient(135deg, var(--bubble-user), #357ABD);
        color: white;
    }

    .chat-bubble.ai {
        color: var(--text);
    }

    @keyframes slideUp {
        from { 
            transform: perspective(500px) translateY(30px) translateZ(0); 
            opacity: 0; 
        }
        to { 
            transform: perspective(500px) translateY(0) translateZ(10px); 
            opacity: 1; 
        }
    }

    /* Improved placeholder loading animation */
    .chat-bubble.placeholder {
        background: linear-gradient(135deg, var(--bubble-ai), #333);
        animation: pulse 1.5s infinite alternate;
    }

    @keyframes pulse {
        0% {
            opacity: 0.7;
            transform: perspective(500px) translateZ(10px);
        }
        100% {
            opacity: 1;
            transform: perspective(500px) translateZ(15px);
        }
    }

    .chat-bubble.editable {
        padding: 16px 20px;
        background: linear-gradient(135deg, #555, #333);
        border: 1px solid var(--primary);
        white-space: normal;
        min-height: 40px;
        height: auto; /* Allow bubble to grow with textarea */
    }

    .chat-bubble.editable textarea {
        width: 100%;
        background: transparent;
        border: none;
        color: white;
        font-size: 16px;
        line-height: 1.5;
        resize: none;
        outline: none;
        padding: 0;
        min-height: 40px;
        max-height: 300px; /* Increased for big messages */
        overflow-y: auto;
        scrollbar-width: thin;
        scrollbar-color: rgba(255, 255, 255, 0.3) rgba(0, 0, 0, 0);
    }

    .chat-bubble.editable textarea::-webkit-scrollbar {
        width: 6px;
    }

    .chat-bubble.editable textarea::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.3);
        border-radius: 4px;
    }

    /* Improved emoji button styles */
    .retry-button, .quote-button, .copy-button, .edit-button {
        background: transparent;
        border: none;
        color: rgba(255, 255, 255, 0.85); /* Darker, more visible emojis */
        cursor: pointer;
        font-size: 18px;
        opacity: 0; /* Hidden by default */
        transition: opacity 0.2s ease, transform 0.2s ease;
        margin: 0 5px;
        transform-origin: center;
    }

    /* Only show buttons when hovering over the message container */
    .chat-bubble-wrapper:hover .retry-button,
    .chat-bubble-wrapper:hover .quote-button,
    .chat-bubble-wrapper:hover .copy-button,
    .chat-bubble-wrapper:hover .edit-button {
        opacity: 0.85; /* More visible when hovered */
    }

    /* Full opacity and scale effect on direct button hover */
    .retry-button:hover, .quote-button:hover, .copy-button:hover, .edit-button:hover {
        opacity: 1;
        transform: scale(1.2);
    }

    .chat-bubble-wrapper.user .edit-button {
        color: rgba(255, 255, 255, 0.85); /* Darker for user messages */
        order: -1; /* Places emoji before bubble */
        margin-right: 10px; /* Reduced space from bubble */
    }

    .chat-bubble-wrapper.ai .quote-button {
        order: 1; /* Places emojis after bubble */
        margin-left: 8px; /* Initial spacing from bubble */
    }

    .chat-bubble-wrapper.ai .quote-button,
    .chat-bubble-wrapper.ai .retry-button,
    .chat-bubble-wrapper.ai .copy-button {
        margin-left: 8px; /* Consistent spacing between AI icons */
    }

    .settings-button {
        position: absolute;
        top: 50%;
        right: 20px;
        transform: translateY(-50%);
        background: transparent;
        border: none;
        color: var(--primary);
        cursor: pointer;
        font-size: 36px;
        z-index: 100;
        padding: 8px;
        transition: transform 0.2s ease;
    }
    
    .settings-button:hover {
        transform: translateY(-50%) scale(1.1);
    }

    .settings-menu {
        display: none;
        position: absolute;
        top: 65px;
        right: 20px;
        background: linear-gradient(135deg, var(--side-bg), var(--secondary));
        border-radius: var(--border-radius);
        box-shadow: var(--shadow);
        padding: 20px;
        z-index: 20;
        min-width: 200px;
        transform: perspective(500px) translateZ(10px);
        transition: background 0.3s ease, transform 0.3s ease;
        transform-origin: top right;
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
    }

    .settings-menu.active {
        display: block;
        animation: smoothSlideIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
    }

    @keyframes smoothSlideIn {
        from { 
            transform: perspective(500px) translateZ(0) scale(0.95) translateY(-10px); 
            opacity: 0; 
        }
        to { 
            transform: perspective(500px) translateZ(10px) scale(1) translateY(0); 
            opacity: 1; 
        }
    }

    .settings-menu button {
        display: block;
        width: 100%;
        padding: 12px;
        margin: 8px 0;
        border: none;
        background: linear-gradient(135deg, var(--secondary), var(--side-bg));
        color: var(--text);
        border-radius: 10px;
        cursor: pointer;
        box-shadow: var(--shadow);
        transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.2s ease;
        font-size: 16px;
    }

    .settings-menu button:hover {
        transform: translateY(-3px) translateZ(5px);
        box-shadow: 0px 8px 20px rgba(0, 0, 0, 0.3);
    }

    .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        z-index: 30;
        justify-content: center;
        align-items: center;
        backdrop-filter: blur(5px);
    }

    .modal.active {
        display: flex;
        animation: fadeIn 0.4s cubic-bezier(0.22, 0.61, 0.36, 1);
    }

    @keyframes fadeIn {
        from { 
            opacity: 0; 
            backdrop-filter: blur(0px);
        }
        to { 
            opacity: 1; 
            backdrop-filter: blur(5px);
        }
    }

    @keyframes smoothPopIn {
        from { 
            transform: perspective(500px) translateZ(0) scale(0.9); 
            opacity: 0; 
            box-shadow: 0px 5px 20px rgba(0, 0, 0, 0.3);
        }
        to { 
            transform: perspective(500px) translateZ(20px) scale(1); 
            opacity: 1; 
            box-shadow: 0px 15px 40px rgba(0, 0, 0, 0.5);
        }
    }

    .modal-content {
        background: linear-gradient(135deg, var(--side-bg), var(--secondary));
        padding: 24px;
        border-radius: var(--border-radius);
        max-width: 505px;
        width: 85%;
        box-shadow: 0px 15px 40px rgba(0, 0, 0, 0.5);
        transform: perspective(500px) translateZ(20px);
        transition: all 0.3s cubic-bezier(0.165, 0.84, 0.44, 1);
        animation: smoothPopIn 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        box-sizing: border-box;
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
    }

    .modal h2 {
        color: var(--primary);
        margin-bottom: 16px;
        font-size: 26px;
    }

    .key-display {
        background: var(--secondary);
        padding: 10px;
        border-radius: 8px;
        margin: 10px 0;
        word-break: break-all;
        box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.2);
        transition: background 0.3s ease;
    }

    .story-input {
        width: calc(100% - 12px);
        height: 100px;
        padding: 8px;
        border-radius: 10px;
        background: var(--side-bg);
        border: 1px solid rgba(255, 255, 255, 0.1);
        color: var(--text);
        font-size: 16px;
        margin: 13px 0;
        resize: none;
        box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.2);
        max-height: 100px;
        overflow-y: auto;
        box-sizing: border-box;
        transition: all 0.3s ease;
    }

    .story-input:focus {
        outline: none;
        border-color: var(--primary);
        background: var(--secondary);
        box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.2), 0 0 0 2px rgba(54, 140, 255, 0.2);
    }

    .close-modal {
        background: linear-gradient(135deg, var(--primary), #357ABD);
        color: white;
        border: none;
        padding: 10px 19px;
        border-radius: 10px;
        cursor: pointer;
        margin-top: 16px;
        box-shadow: var(--shadow);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        font-size: 16px;
    }

    .close-modal:hover {
        transform: translateY(-3px) translateZ(5px);
        box-shadow: 0px 8px 20px rgba(0, 0, 0, 0.3);
    }
    
    .yt-container {
        display: flex;
        gap: 10px;
    }
    
    .yt-link-input,
    .yt-additional-input {
        width: calc(50% - 12px);
        height: 100px;
        padding: 8px;
        border-radius: 10px;
        background: var(--side-bg);
        border: 1px solid rgba(255, 255, 255, 0.1);
        color: var(--text);
        font-size: 16px;
        margin: 13px 0;
        resize: none;
        box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.2);
        max-height: 100px;
        overflow-y: auto;
        transition: all 0.3s ease;
    }
    
    .yt-link-input:focus,
    .yt-additional-input:focus {
        outline: none;
        border-color: var(--primary);
        background: var(--secondary);
        box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.2), 0 0 0 2px rgba(54, 140, 255, 0.2);
    }

    #accessKeyLogin, #apiKeyLogin {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background: linear-gradient(135deg, var(--secondary), var(--side-bg));
        padding: 2rem;
        border-radius: var(--border-radius);
        box-shadow: var(--shadow);
        width: 100%;
        max-width: 400px;
        position: fixed;
        left: 50%;
        top: 50%;
        transform: perspective(500px) translate(-50%, -50%) translateZ(20px);
        transition: background 0.3s ease, transform 0.3s ease;
        animation: loginPopIn 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
    }

    @keyframes loginPopIn {
        from { 
            transform: perspective(500px) translate(-50%, -50%) translateZ(0) scale(0.9); 
            opacity: 0; 
        }
        to { 
            transform: perspective(500px) translate(-50%, -50%) translateZ(20px) scale(1); 
            opacity: 1; 
        }
    }

    #apiKeyLogin {
        display: none;
    }

    .login-header {
        font-size: 24px;
        font-weight: 600;
        margin-bottom: 1.5rem;
        color: var(--primary);
        text-transform: uppercase;
        letter-spacing: 1px;
        text-align: center;
        width: 100%;
    }

    .login-input {
        width: 100%;
        padding: 12px;
        margin: 10px 0;
        border-radius: var(--border-radius);
        background: var(--side-bg);
        border: 1px solid #333;
        color: var(--text);
        font-size: 16px;
        text-align: center;
        box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.2);
        transition: all 0.3s ease;
    }

    .login-input:focus {
        outline: none;
        border-color: var(--primary);
        background: var(--secondary);
        box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.2), 0 0 0 2px rgba(54, 140, 255, 0.2);
    }

    .login-button {
        width: 100%;
        padding: 12px;
        margin-top: 20px;
        border-radius: var(--border-radius);
        background: linear-gradient(135deg, var(--primary), #357ABD);
        color: white;
        font-size: 16px;
        font-weight: 500;
        cursor: pointer;
        box-shadow: var(--shadow);
        transition: all 0.3s ease;
        border: none;
    }

    .login-button:hover {
        transform: translateY(-3px) translateZ(5px);
        box-shadow: 0px 8px 15px rgba(0, 0, 0, 0.3);
    }

    .success-message {
        color: #4CAF50;
        margin-top: 10px;
        font-size: 14px;
        opacity: 0;
        transition: opacity 0.3s ease;
        text-align: center;
        width: 100%;
    }

    .chat-container {
        display: none;
        flex-direction: row;
        width: clamp(47.5%, 50%, 1200px);
        max-width: 90%;
        height: 90vh;
        position: relative;
        overflow: hidden;
        transform: perspective(500px) translateZ(10px);
        filter: drop-shadow(0 10px 30px rgba(0, 0, 0, 0.8));
    }

    .chat-main {
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        border-radius: var(--border-radius);
        overflow: hidden;
        background: linear-gradient(135deg, var(--secondary), var(--side-bg));
        box-shadow: 0px 15px 60px rgba(0, 0, 0, 0.9);
        position: relative;
        z-index: 5;
        transition: background 0.3s ease;
        padding: 20px;
    }

    .header {
        background: linear-gradient(135deg, var(--secondary), var(--side-bg));
        padding: 20px;
        text-align: center;
        font-size: 36px;
        font-weight: 600;
        letter-spacing: 1px;
        color: var(--primary);
        text-transform: uppercase;
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.25);
        transition: background 0.3s ease, color 0.3s ease;
        animation: glowMove 3s ease-in-out infinite;
        border-radius: var(--border-radius);
        margin-bottom: 20px;
    }

    @keyframes glowMove {
        0%, 100% { text-shadow: 0 0 5px var(--primary); transform: translateX(-2px) translateZ(0); }
        50% { text-shadow: 0 0 15px var(--primary), 0 0 25px var(--primary); transform: translateX(2px) translateZ(10px); }
    }
    
    .current-chat-indicator {
        background: var(--secondary);
        color: var(--text);
        font-size: 14px;
        padding: 6px 12px;
        border-radius: 6px;
        position: absolute;
        bottom: -15px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 10;
        white-space: nowrap;
        overflow: visible;
        max-width: 90%;
        text-transform: none;
        box-shadow: var(--shadow);
        transition: background 0.3s ease, color 0.3s ease;
    }

    .sidebar-toggle {
        position: absolute;
        left: 20px;
        top: 50%;
        transform: translateY(-50%);
        background: transparent;
        border: none;
        color: var(--primary);
        cursor: pointer;
        font-size: 36px;
        z-index: 10;
        padding: 8px;
        transition: transform 0.2s ease;
    }
    
    .sidebar-toggle:hover {
        transform: translateY(-50%) scale(1.1);
    }
    
    .sidebar-edge {
        position: absolute;
        left: 0;
        top: 0;
        height: 100%;
        width: 4px;
        background: var(--primary);
        opacity: 0.4;
        cursor: pointer;
        z-index: 15;
        transition: opacity 0.3s ease;
    }
    
    .sidebar-edge:hover {
        opacity: 0.8;
    }

    .chat-box {
        position: relative;
        flex-grow: 1;
        overflow-y: auto;
        padding: 20px;
        display: flex;
        flex-direction: column;
        gap: 25px; /* Controls spacing between bubbles */
        scrollbar-width: thin;
        scrollbar-color: rgba(255, 255, 255, 0.3) rgba(0, 0, 0, 0);
        background: linear-gradient(135deg, var(--side-bg), var(--secondary));
        transition: background 0.3s ease;
        border-radius: var(--border-radius);
        margin-bottom: 20px;
    }

    .chat-box::-webkit-scrollbar {
        width: 6px;
    }

    .chat-box::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.3);
        border-radius: 4px;
    }

    .full-screen-button {
        background: transparent;
        border: none;
        color: grey;
        cursor: pointer;
        font-size: 20px;
        padding: 8px;
        position: absolute;
        top: 10px;
        left: 10px;
        opacity: 0.5;
        transition: opacity 0.2s ease, transform 0.2s ease;
        z-index: 10;
    }
    
    .full-screen-button:hover {
        opacity: 1;
        transform: scale(1.1);
    }

    .chat-container.full-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        max-width: 100%;
        z-index: 1000;
        background: var(--background);
        padding: 0;
        box-sizing: border-box;
    }

    .chat-container.full-screen .chat-main {
        width: 100%;
        height: 100%;
        padding: 20px;
        box-sizing: border-box;
        border-radius: 0;
    }

    .chat-container.full-screen .chat-box {
        padding-top: 40px;
        margin-bottom: 0;
        flex-grow: 1;
        height: calc(100% - 140px); /* Adjust for header and input heights */
    }

    .chat-container.full-screen .input-container {
        position: relative;
        bottom: 0;
        width: 100%;
        margin: 0;
        padding: 15px 20px;
        box-sizing: border-box;
        z-index: 10;
    }

    .input-container {
        display: flex;
        flex-direction: column;
        padding: 15px;
        background: linear-gradient(135deg, var(--secondary), var(--side-bg));
        gap: 15px;
        box-shadow: 0 -5px 20px rgba(0, 0, 0, 0.2);
        transition: background 0.3s ease;
        border-radius: var(--border-radius);
        position: relative;
    }
    
    .preset-buttons {
        display: flex;
        gap: 8px;
        justify-content: flex-end;
        align-items: center;
        width: 100%;
        overflow: hidden;
        white-space: nowrap;
        position: relative;
        z-index: 100;
        margin-bottom: 10px;
        padding-right: 15px;
    }
    
    .preset-buttons button {
        background: linear-gradient(135deg, var(--primary), #357ABD);
        padding: 2px 5px;
        border-radius: 6px;
        color: white;
        font-size: 8px;
        font-weight: 600;
        cursor: pointer;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        transition: all 0.2s ease-out;
        border: none;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        line-height: 1.2;
        position: relative;
        z-index: 100;
    }
    
    .preset-buttons button:hover {
        transform: scale(1.05) translateY(-2px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }

    /* Save button pulse animation */
    @keyframes savePulse {
        0% {
            box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.7);
        }
        70% {
            box-shadow: 0 0 0 10px rgba(76, 175, 80, 0);
        }
        100% {
            box-shadow: 0 0 0 0 rgba(76, 175, 80, 0);
        }
    }

    .preset-buttons button:last-child {
        animation: savePulse 2s infinite;
    }
    
    @media (max-width: 480px) {
        .preset-buttons {
            gap: 6px;
            margin-bottom: 8px;
            padding-right: 10px;
        }
        
        .preset-buttons button {
            padding: 1px 3px;
            font-size: 7px;
        }
    }        

    .input-row {
        display: flex;
        gap: 15px;
        align-items: center;
    }
    
    .input-container textarea {
        flex-grow: 1;
        padding: 10px;
        border-radius: var(--border-radius);
        border: none;
        background: var(--side-bg);
        color: var(--text);
        font-size: 15px;
        line-height: 1.5;
        box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.2);
        transition: all 0.3s ease-in-out;
        resize: none;
        min-height: 40px;
        max-height: 130px;
        overflow-y: auto;
        scrollbar-width: thin;
        scrollbar-color: rgba(255, 255, 255, 0.3) rgba(0, 0, 0, 0);
    }

    .input-container textarea::-webkit-scrollbar {
        width: 6px;
    }

    .input-container textarea::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.3);
        border-radius: 4px;
    }

    .input-container textarea:focus {
        outline: none;
        background: var(--secondary);
        box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.2), 0 0 0 2px rgba(54, 140, 255, 0.2);
    }

    .input-container button {
        background: linear-gradient(135deg, var(--primary), #357ABD);
        padding: 10px 15px;
        border-radius: var(--border-radius);
        border: none;
        color: white;
        font-size: 18px;
        cursor: pointer;
        box-shadow: var(--shadow);
        transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.2s ease;
        white-space: nowrap;
    }

    .input-container button:hover {
        transform: translateY(-3px) translateZ(5px);
        box-shadow: 0px 8px 20px rgba(0, 0, 0, 0.3);
    }

    .input-container button.active {
        background: linear-gradient(135deg, #FF5555, #CC4444);
        cursor: pointer; /* Keep clickable for abort */
    }
    
    .side-extension {
        width: 300px;
        height: 100%;
        background: linear-gradient(180deg, var(--secondary) 0%, var(--side-bg) 100%);
        border-radius: var(--border-radius);
        box-shadow: var(--shadow);
        z-index: 20;
        padding: 25px;
        position: absolute;
        left: -310px;
        top: 0;
        transition: left 0.3s ease, background 0.3s ease;
        overflow-y: auto;
        visibility: hidden;
        transform: perspective(500px) translateZ(10px);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
    }

    .side-extension.active {
        left: 0;
        visibility: visible;
        animation: smoothSideSlideIn 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
    }
    
    @keyframes smoothSideSlideIn {
        from { 
            left: -310px; 
            opacity: 0.8; 
            box-shadow: 0px 5px 15px rgba(0, 0, 0, 0.2);
        }
        to { 
            left: 0; 
            opacity: 1; 
            box-shadow: var(--shadow);
        }
    }
    
    .side-extension.edge-only {
        left: -292px;
        visibility: visible;
    }

    .side-extension-header {
        font-size: 26px;
        font-weight: 700;
        color: var(--primary);
        margin-bottom: 30px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 2px solid rgba(255, 255, 255, 0.1);
        padding-bottom: 15px;
    }

    .close-sidebar {
        background: rgba(255, 255, 255, 0.1);
        border: none;
        color: var(--text);
        font-size: 20px;
        cursor: pointer;
        transition: transform 0.2s ease, background 0.2s ease;
        width: 36px;
        height: 36px;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .close-sidebar:hover {
        transform: scale(1.1);
        background: rgba(255, 255, 255, 0.2);
    }

    .side-button {
        display: block;
        width: 100%;
        padding: 14px 18px;
        margin: 10px 0;
        background: linear-gradient(145deg, var(--secondary), var(--side-bg));
        color: var(--text);
        border-radius: 14px;
        border: none;
        cursor: pointer;
        text-align: left;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
        transition: all 0.3s ease;
        transform: perspective(500px) translateZ(5px);
        font-size: 16px;
        font-weight: 500;
        position: relative;
        overflow: hidden;
    }

    .side-button:hover {
        transform: perspective(500px) translateZ(10px) translateY(-2px);
        box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
    }

    .side-button.new-chat {
        background: linear-gradient(135deg, var(--primary), #357ABD);
        color: white;
        padding: 16px 18px;
        margin-bottom: 20px;
        text-align: center;
        font-weight: 600;
        letter-spacing: 0.5px;
    }
    
    .side-button.new-chat:hover {
        background: linear-gradient(135deg, #4a97ff, #4389d9);
    }

    .side-button.current {
        background: linear-gradient(145deg, var(--highlight), var(--secondary));
        border-left: 4px solid var(--primary);
        padding-left: 14px;
        font-weight: bold;
    }
    
    .side-button.current::after {
        content: '';
        position: absolute;
        top: 0;
        right: 0;
        height: 100%;
        width: 4px;
        background: var(--primary);
    }
    
    .chat-actions {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        position: relative;
    }
    
    .delete-chat {
        background: linear-gradient(135deg, #FF5555, #CC4444);
        color: white;
        border: none;
        border-radius: 10px;
        padding: 8px 12px;
        font-size: 14px;
        cursor: pointer;
        box-shadow: var(--shadow);
        transition: all 0.3s ease;
        opacity: 0.9;
    }
    
    .delete-chat:hover {
        transform: scale(1.05) translateZ(5px);
        opacity: 1;
    }
    
    .saved-script-delete-button {
        background: linear-gradient(135deg, #FF5555, #CC4444);
        color: white;
        border: none;
        border-radius: 5px;
        padding: 5px 10px;
        cursor: pointer;
        font-size: 14px;
        transition: transform 0.2s ease;
        margin-left: 10px;
    }
    
    .saved-script-delete-button:hover {
        transform: scale(1.05);
    }

    /* Success message animation */
    @keyframes successFade {
        0% { 
            opacity: 0; 
            transform: translateY(10px);
        }
        10% { 
            opacity: 1; 
            transform: translateY(0);
        }
        90% { 
            opacity: 1; 
            transform: translateY(0);
        }
        100% { 
            opacity: 0; 
            transform: translateY(-10px);
        }
    }

    .success-notification {
        position: fixed;
        bottom: 20px;
        left: 50% !important;
        transform: translateX(-50%) !important;
        background: linear-gradient(135deg, #4CAF50, #2E7D32);
        color: white;
        padding: 12px 24px;
        border-radius: 30px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        z-index: 1000;
        font-weight: 500;
        display: flex;
        align-items: center;
        gap: 8px;
        animation: successFade 3s forwards;
    }

    .success-notification::before {
        content: "‚úì";
        font-size: 18px;
        font-weight: bold;
    }
    
    .error-notification {
        background: linear-gradient(135deg, #FF5555, #CC4444);
    }
    
    .error-notification::before {
        content: "‚úó";
    }

    .full-page-loader {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        backdrop-filter: blur(5px);
    }
    
    .loader-content {
        text-align: center;
    }
    
    .spinner {
        width: 50px;
        height: 50px;
        border: 5px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top-color: var(--primary);
        animation: spin 1s ease-in-out infinite;
        margin: 0 auto 20px;
    }
    
    @keyframes spin {
        to { transform: rotate(360deg); }
    }
    
    .loader-text {
        color: white;
        font-size: 18px;
        font-weight: 500;
    }
    
    .fade-out {
        animation: fadeOut 0.5s forwards;
    }
    
    @keyframes fadeOut {
        from { opacity: 1; }
        to { opacity: 0; }
    }

    .animate-in {
        animation: slideIn 0.5s forwards;
    }
    
    @keyframes slideIn {
        from { 
            opacity: 0;
            transform: translateY(20px);
        }
        to { 
            opacity: 1;
            transform: translateY(0);
        }
    }

    @media (max-width: 480px) {
        .chat-container {
            width: 100%;
            height: 100vh;
            border-radius: 0;
            padding: 10px;
        }

        body { padding: 0; }

        .preset-buttons {
            padding: 5px;
            gap: 4px;
        }

        .preset-buttons button {
            padding: 3px 6px;
            font-size: 9px;
        }

        .side-extension {
            width: 250px;
            left: -260px;
        }

        .side-extension.active { left: 0; }
    }

    #ytLinkModal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        z-index: 30;
        justify-content: center;
        align-items: center;
        backdrop-filter: blur(5px);
    }

    #ytLinkModal.active {
        display: flex;
        animation: fadeIn 0.3s ease;
    }

    .yt-link-input {
        width: 90%;
        padding: 12px;
        margin: 10px auto;
        background: var(--side-bg);
        border: 1px solid rgba(255, 255, 255, 0.1);
        color: var(--text);
        font-size: 16px;
        box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.2);
        transition: all 0.3s ease;
        display: block;
    }

    .yt-link-input:focus {
        outline: none;
        border-color: var(--primary);
        background: var(--secondary);
        box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.2), 0 0 0 2px rgba(54, 140, 255, 0.2);
    }

    #savedScriptsContainer::-webkit-scrollbar {
        width: 6px;
    }

    #savedScriptsContainer::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.3);
        border-radius: 4px;
    }

    .saved-script {
        margin-bottom: 15px;
        padding: 10px;
        background: var(--side-bg);
        border-radius: 8px;
        white-space: pre-wrap;
        word-wrap: break-word;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    
    .saved-script:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }

    .script-separator {
        border-top: 1px dashed var(--primary);
        margin: 10px 0;
    }
    
    /* Mobile optimizations */
    .mobile-device .chat-bubble {
        max-width: 85%;
    }
    
    .mobile-device .chat-box {
        padding: 15px 10px;
    }
    
    .mobile-device .input-container {
        padding: 10px;
    }
    
    .mobile-device .preset-buttons button {
        font-size: 7px;
        padding: 1px 3px;
    }
    
    .chat-bubble-wrapper.ai .button-group {
        display: flex;
        gap: 6px;
        margin-left: 12px;
    }
    
    .chat-bubble-wrapper.ai .button-group button {
        margin: 0;
    }
    
    /* New styles for emoji buttons */
    .emoji-options {
        display: flex;
        gap: 8px;
        justify-content: center;
        margin-top: 8px;
        opacity: 0.7;
        transition: opacity 0.2s ease;
    }

    .emoji-options:hover {
        opacity: 1;
    }

    .emoji-option {
        background: var(--secondary);
        border: none;
        border-radius: 6px;
        padding: 4px 8px;
        font-size: 14px;
        cursor: pointer;
        transition: background 0.2s ease, transform 0.1s ease;
        }

    .emoji-option:hover {
        background: var(--primary);
        color: white;
    }

    .emoji-option:active {
        transform: scale(0.95);
    }

    /* Model selection dropdown */
    .model-select {
        background: var(--side-bg);
        color: var(--text);
        border: 1px solid var(--secondary);
        border-radius: 8px;
        padding: 6px 10px;
        margin-right: 10px;
        font-size: 14px;
        outline: none;
        transition: background 0.2s ease, border-color 0.2s ease;
    }

    .model-select:focus {
        border-color: var(--primary);
        background: var(--secondary);
    }

    .input-row {
        display: flex;
        align-items: center;
    }
    
    .chat-bubble-wrapper.ai {
        position: relative;
    }
    
    .chat-bubble-wrapper.ai .emoji-options {
        position: absolute;
        left: 0px; /* Exactly match the AI bubble's left padding */
        top: calc(100% + 8px);
        display: flex;
        gap: 10px; /* Slightly more space between emoji options */
        align-items: center;
        opacity: 1 !important; /* Ensure they never fade out */
    }
    
    .chat-bubble-wrapper.ai .emoji-option {
        font-size: 16px; /* Slightly larger */
        padding: 6px 10px; /* More padding */
        background: var(--secondary);
        border-radius: 8px;
        cursor: pointer;
        transition: none; /* Remove any fade or transform effects */
    }
    
    .chat-bubble-wrapper.ai .emoji-option:hover {
        background: var(--primary);
        color: white;
    }
    
    .emoji-options {
        display: flex;
        gap: 8px;
        justify-content: center;
        margin-top: 8px;
        background: var(--secondary);
        border-radius: 20px;
        padding: 6px 10px;
        align-self: center;
        max-width: 75%;
        opacity: 0.7;
        transition: opacity 0.2s ease, transform 0.2s ease;
    }
    
    .emoji-options:hover {
        opacity: 1;
        transform: translateY(-2px);
    }
    
    .emoji-option {
        background: transparent;
        border: none;
        border-radius: 6px;
        padding: 4px 8px;
        font-size: 14px;
        cursor: pointer;
        transition: background 0.2s ease, transform 0.1s ease;
        display: flex;
        align-items: center;
        gap: 4px;
    }
    
    .emoji-option:hover {
        background: var(--primary);
        color: white;
    }
    
    .emoji-option:active {
        transform: scale(0.95);
    }

</style>
</head>
<body>
    <img id="bgGif" src="https://media4.giphy.com/media/v1.Y2lkPTc5MGI3NjExNzJoeXZjbzcxbG52c2Nkemtxc2FvNXE1azFpNHZ3MXZoaXR5cHRjdSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/QTJMtK3tbkjTadk8as/giphy.gif" alt="Background animation">

    <div id="accessKeyLogin">
        <div class="login-header">Access Verification</div>
        <input type="password" id="accessKey" class="login-input" placeholder="Enter your access key">
        <button onclick="verifyAccessKey()" class="login-button">Continue</button>
        <div id="accessKeyMessage" class="success-message"></div>
    </div>

    <div id="apiKeyLogin">
        <div class="login-header">API Verification</div>
        <input type="password" id="apiKey" class="login-input" placeholder="Enter your Claude AI API key">
        <button onclick="verifyApiKey()" class="login-button">Login</button>
        <div id="apiKeyMessage" class="success-message"></div>
    </div>

    <div id="chatInterface" class="chat-container">
        <div class="side-extension" id="sideExtension">
            <div class="side-extension-header">
                <span>Chat Library</span>
                <button class="close-sidebar" onclick="hideSidebar()">√ó</button>
            </div>
            <button class="side-button new-chat" onclick="newChat()">New Chat +</button>
            <div id="chatList"></div>
            <div class="sidebar-edge" onclick="toggleSideExtension()"></div>
        </div>
        
        <div class="chat-main">
            <div class="header">
                <button onclick="toggleSideExtension()" id="sidebarToggle" class="sidebar-toggle">üìö</button>
                Reddit Script Writer
                <button onclick="toggleSettings()" id="settingsButton" class="settings-button">‚öôÔ∏è</button>
                <div class="current-chat-indicator" id="currentChatIndicator">Chat 1</div>
            </div>
            <div class="settings-menu" id="settingsMenu">
                <button onclick="showKeys()">üîë View Keys</button>
                <button onclick="toggleTheme()" id="themeToggle">üåó Toggle Theme</button>
                <button onclick="showSavedScripts()">üìú Saved Scripts</button>
                <button onclick="logout()">üö™ Logout</button>
            </div>
            <div id="chatBox" class="chat-box">
                <button onclick="toggleFullScreen()" id="fullScreenButton" class="full-screen-button">‚õ∂</button>
            </div>
            <div class="input-container">
                <div class="preset-buttons" id="presetButtons">
                    <button onclick="showStoryModal()">Add Story</button>
                    <button onclick="showYtLinkModal()">YT Link</button>
                    <button onclick="setPrompt('REGEN'); sendMessage()">RE-GEN</button>
                    <button onclick="setPrompt('SAME'); sendMessage()">SAME</button>
                    <button onclick="setPrompt('MENU'); sendMessage()">MENU</button>
                    <button onclick="saveScript()" style="background: linear-gradient(135deg, #4CAF50, #388E3C);">SAVE</button>
                </div>
                <div class="input-row">
                    <textarea id="userInput" placeholder="Type your message..." rows="1" oninput="autoExpand(this)"></textarea>
                    <div class="model-select-container">
                        <select id="modelSelect" class="model-select">
                            <option value="claude-sonnet-4-5-20250929" selected>Claude Sonnet 4.5 (Smartest)</option>
                            <option value="claude-haiku-4-5-20251001">Claude Haiku 4.5 (Fastest)</option>
                            <option value="claude-opus-4-1-20250805">Claude Opus 4.1 (Reasoning)</option>
                            <option value="claude-3-5-sonnet-20241022">Claude 3.5 Sonnet (Legacy)</option>
                            <option value="claude-3-7-sonnet-20250219">Claude 3.7 Sonnet (Legacy)</option>
                        </select>
                    </div>
                    <button id="sendStopButton" onclick="toggleSendStop()">‚û§</button>
                </div>
            </div>
        </div>
    </div>

    <div id="keysModal" class="modal">
        <div class="modal-content">
            <h2>Your Keys</h2>
            <div>
                <p>Access Key:</p>
                <div id="accessKeyDisplay" class="key-display"></div>
            </div>
            <div>
                <p>API Key:</p>
                <div id="apiKeyDisplay" class="key-display"></div>
            </div>
            <button onclick="closeModal('keysModal')" class="close-modal">Close</button>
        </div>
    </div>

    <div id="storyModal" class="modal">
        <div class="modal-content">
            <h2>Paste Your Reddit Story</h2>
            <textarea id="storyInput" class="story-input" placeholder="Paste the viral Reddit story here..."></textarea>
            <div style="display: flex; justify-content: space-between; margin-top: 16px; width: 100%; box-sizing: border-box;">
                <button onclick="submitStory()" class="close-modal" style="flex: 1; margin-right: 12px; padding: 10px 0; box-sizing: border-box; font-size: 16px;">Submit</button>
                <button onclick="closeModal('storyModal')" class="close-modal" style="flex: 1; margin-left: 12px; background: #555; padding: 10px 0; box-sizing: border-box; font-size: 16px;">Cancel</button>
            </div>
        </div>
    </div>

    <div id="ytLinkModal" class="modal">
        <div class="modal-content">
            <h2>Add YouTube Link</h2>
            <div class="yt-container">
                <textarea id="ytLinkInput" class="yt-link-input" placeholder="Paste YouTube URL here..."></textarea>
                <textarea id="ytAdditionalInput" class="yt-additional-input" placeholder="Additional content (details, context, etc.)..."></textarea>
            </div>
            <div style="display: flex; justify-content: space-between; margin-top: 16px; width: 100%; box-sizing: border-box;">
                <button onclick="submitYtLink()" class="close-modal" style="flex: 1; margin-right: 12px; padding: 10px 0; box-sizing: border-box; font-size: 16px;">Submit</button>
                <button onclick="closeModal('ytLinkModal')" class="close-modal" style="flex: 1; margin-left: 12px; background: #555; padding: 10px 0; box-sizing: border-box; font-size: 16px;">Cancel</button>
            </div>
        </div>
    </div>

    <div id="savedScriptsModal" class="modal">
        <div class="modal-content">
            <h2>Saved Scripts</h2>
            <div id="savedScriptsContainer" style="max-height: 400px; overflow-y: auto; background: var(--secondary); padding: 15px; border-radius: 10px; margin: 10px 0;">
                <div id="savedScriptsList"></div>
            </div>
            <div style="display: flex; justify-content: space-between; margin-top: 16px;">
                <button onclick="downloadScripts()" class="close-modal" style="flex: 1; margin-right: 8px; padding: 10px 0;">Download</button>
                <button onclick="clearSavedScripts()" class="close-modal" style="flex: 1; margin: 0 8px; background: #FF5555; padding: 10px 0;">Clear</button>
                <button onclick="closeModal('savedScriptsModal')" class="close-modal" style="flex: 1; margin-left: 8px; padding: 10px 0;">Close</button>
            </div>
        </div>
    </div>

    <script>
    const TEMPLATE_TEXT = `Here is a viral Reddit story:

'[Insert the viral story you provide.]'

--------------------

Use this as inspiration to write a new, 60 second YouTube Shorts script. The new story should be similar but not identical, with a fresh twist or perspective. Use very simple, 5th-grade-level language so anyone can understand it.
Make the story realistic and believable, including small, everyday details to make it feel authentic. Format it in a style similar to the scripts that preformed well in the database. With a strong hook to grab attention, a build-up of tension, and a satisfying or shocking or emotional resolution at the end.

Keep the new story about 1500 characters long, and ensure it flows naturally as if it‚Äôs being retold by someone sharing their experience.`;

    const YT_TEMPLATE_TEXT = `Here is a viral Reddit story:

'[Insert the viral story you provide.]'

--------------------

Use this as inspiration to write a new, 60 second YouTube Shorts script. The new story should be similar but not identical, with a fresh twist or perspective. Use very simple, 5th-grade-level language so anyone can understand it.
Make the story realistic and believable, including small, everyday details to make it feel authentic. Format it in a style similar to the scripts that preformed well in the database. With a strong hook to grab attention, a build-up of tension, and a satisfying or shocking or emotional resolution at the end.

Keep the new story about 1500 characters long, and ensure it flows naturally as if it‚Äôs being retold by someone sharing their experience.`;

    const cookingMessages = [
        "Brewing some script juice...",
        "Squeezing out the sauce...",
        "Crafting TikTok gold...",
        "Mixing viral vibes...",
        "Cooking up social magic...",
        "Stirring some scroll-stopping content...",
        "Blending the next big script...",
        "Whipping up Insta-worthy lines..."
    ];
    
    let currentAccessKey = '';
    let currentApiKey = '';
    let chatSessions = getChatSessions() || {};
    let sessionNames = getSavedSessionNames() || {};
    let currentSessionId = '';
    
    if (Object.keys(chatSessions).length === 0) {
        currentSessionId = Date.now().toString();
        chatSessions[currentSessionId] = [];
        sessionNames[currentSessionId] = `Chat 1`;
        setChatSessions(chatSessions);
        setCookie('sessionNames', JSON.stringify(sessionNames), 7);
    } else {
        currentSessionId = Object.keys(chatSessions)[0];
    }
    
    let isRequestPending = false;
    let abortController = null;
    let currentStory = ''; // To store the story for display in user bubble
    let currentTranscript = ''; // To store the transcript for YT link submissions
    
    // Function to check if a message is a 1-10 options message
    function isNumberedOptionsMessage(message) {
        // Check for the presence of key elements
        const hasStoryHookEmoji = message.includes('üé≠');
        const hasStoryHookText = message.includes('Story Hook:');
        const hasNumberedEmojis = 
            message.includes('1Ô∏è‚É£') && 
            message.includes('2Ô∏è‚É£') && 
            message.includes('3Ô∏è‚É£') && 
            message.includes('4Ô∏è‚É£') && 
            message.includes('5Ô∏è‚É£') && 
            message.includes('6Ô∏è‚É£') && 
            message.includes('7Ô∏è‚É£') && 
            message.includes('8Ô∏è‚É£') && 
            message.includes('9Ô∏è‚É£') && 
            message.includes('üîü');
    
        // Return true if all conditions are met
        return hasStoryHookEmoji && hasStoryHookText && hasNumberedEmojis;
    }
    
    // Function to create emoji buttons for 1-10 options
    function createEmojiOptions(message) {
        // Check for the presence of key elements
        const hasStoryHookEmoji = message.includes('üé≠');
        const hasStoryHookText = message.includes('Story Hook:');
        const hasNumberedEmojis = 
            message.includes('1Ô∏è‚É£') && 
            message.includes('2Ô∏è‚É£') && 
            message.includes('3Ô∏è‚É£') && 
            message.includes('4Ô∏è‚É£') && 
            message.includes('5Ô∏è‚É£') && 
            message.includes('6Ô∏è‚É£') && 
            message.includes('7Ô∏è‚É£') && 
            message.includes('8Ô∏è‚É£') && 
            message.includes('9Ô∏è‚É£') && 
            message.includes('üîü');
    
        // Return true if all conditions are met
        if (hasStoryHookEmoji && hasStoryHookText && hasNumberedEmojis) {
            const emojiOptionContainer = document.createElement('div');
            emojiOptionContainer.className = 'emoji-options';
            
            // Create buttons for 1-10
            for (let i = 1; i <= 10; i++) {
                const button = document.createElement('button');
                button.className = 'emoji-option';
                button.textContent = i === 10 ? 'üîü' : `${i}Ô∏è‚É£`;
                button.onclick = () => {
                    const userInput = document.getElementById('userInput');
                    userInput.value = i.toString();
                    sendMessage();
                };
                emojiOptionContainer.appendChild(button);
            }
            
            return emojiOptionContainer;
        }
        
        return null;
    }
    
    // Modify createAiMessageWrapper to include emoji options
    function createAiMessageWrapper(message) {
        const aiWrapper = document.createElement("div");
        aiWrapper.className = "chat-bubble-wrapper ai";
        
        const aiBubble = document.createElement("div");
        aiBubble.className = "chat-bubble ai";
        aiBubble.textContent = message;
        aiWrapper.appendChild(aiBubble);
    
        const buttonGroup = document.createElement("div");
        buttonGroup.className = "button-group";
    
        const quoteButton = document.createElement("button");
        quoteButton.className = "quote-button";
        quoteButton.textContent = "üí¨";
        quoteButton.title = "Quote this response";
        quoteButton.onclick = () => quoteMessage(aiBubble);
        buttonGroup.appendChild(quoteButton);
    
        const retryButton = document.createElement("button");
        retryButton.className = "retry-button";
        retryButton.textContent = "üîÑ";
        retryButton.title = "Regenerate response";
        retryButton.onclick = () => retryMessage(aiBubble);
        buttonGroup.appendChild(retryButton);
    
        const copyButton = document.createElement("button");
        copyButton.className = "copy-button";
        copyButton.textContent = "üìã";
        copyButton.title = "Copy to clipboard";
        copyButton.onclick = () => copyToClipboard(message);
        buttonGroup.appendChild(copyButton);
    
        aiWrapper.appendChild(buttonGroup);
    
        // Add emoji options
        const emojiOptions = createEmojiOptions(message);
        if (emojiOptions) {
            aiWrapper.appendChild(emojiOptions);
        }
    
        return aiWrapper;
    }

    function verifyAccessKey() {
        const accessKey = document.getElementById('accessKey').value.trim();
        const messageElement = document.getElementById('accessKeyMessage');
        
        if (!accessKey) {
            messageElement.style.color = "#f44336";
            messageElement.textContent = "Please enter an access code.";
            messageElement.style.opacity = "1";
            return;
        }
    
        showLoading();
        fetch('/api/validate-code', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ code: accessKey })
        })
        .then(response => {
            hideLoading();
            if (!response.ok) throw new Error('Invalid code');
            return response.json();
        })
        .then(data => {
            if (data.success) {
                currentAccessKey = accessKey;
                setCookie('accessKey', accessKey, 7);
                messageElement.style.color = "#4CAF50";
                messageElement.textContent = "Access verified successfully!";
                messageElement.style.opacity = "1";
                setTimeout(() => {
                    document.getElementById('accessKeyLogin').style.display = 'none';
                    document.getElementById('apiKeyLogin').style.display = 'flex';
                    messageElement.style.opacity = '0';
                }, 1000);
            }
        })
        .catch(error => {
            messageElement.style.color = "#f44336";
            messageElement.textContent = "Invalid access code.";
            messageElement.style.opacity = "1";
            hideLoading();
        });
    }
    
    function verifyApiKey() {
        const apiKey = document.getElementById('apiKey').value.trim();
        const messageElement = document.getElementById('apiKeyMessage');
        
        if (!apiKey) {
            messageElement.style.color = "#f44336";
            messageElement.textContent = "Please enter an API key.";
            messageElement.style.opacity = "1";
            return;
        }
    
        currentApiKey = apiKey;
        setCookie('apiKey', apiKey, 7);
        messageElement.style.color = "#4CAF50";
        messageElement.textContent = "API key verified successfully!";
        messageElement.style.opacity = "1";
        
        setTimeout(() => {
            document.getElementById('apiKeyLogin').style.display = 'none';
            document.getElementById('chatInterface').style.display = 'flex';
            document.getElementById('settingsButton').style.display = 'block';
            messageElement.style.opacity = '0';
            updateChatList();
            loadChatHistory();
        }, 1000);
    }
    
    function setCookie(name, value, days) {
        let expires = "";
        if (days) {
            const date = new Date();
            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
            expires = "; expires=" + date.toUTCString();
        }
        document.cookie = name + "=" + encodeURIComponent(value) + expires + "; path=/";
    }

    function getCookie(name) {
        const nameEQ = name + "=";
        const ca = document.cookie.split(';');
        for(let i = 0; i < ca.length; i++) {
            let c = ca[i];
            while (c.charAt(0) == ' ') c = c.substring(1, c.length);
            if (c.indexOf(nameEQ) == 0) return decodeURIComponent(c.substring(nameEQ.length, c.length));
        }
        return null;
    }

    function deleteCookie(name) {
        document.cookie = name + '=; Max-Age=-99999999;';
    }

    function setChatSessions(sessions) {
        setCookie('chatSessions', JSON.stringify(sessions), 7);
    }

    function getChatSessions() {
        const sessions = getCookie('chatSessions');
        return sessions ? JSON.parse(sessions) : {};
    }

    async function fetchSavedScripts() {
        try {
            const response = await fetch('/api/saved-scripts');
            if (!response.ok) throw new Error('Failed to fetch saved scripts');
            const data = await response.json();
            return data.scripts;
        } catch (error) {
            console.error('Error fetching saved scripts:', error);
            return [];
        }
    }

    function showModal(modalId) {
        const modal = document.getElementById(modalId);
        document.body.style.overflow = 'hidden'; // Prevent background scrolling
        modal.classList.add('active');
        
        // Add escape key handler
        const escHandler = (e) => {
            if (e.key === 'Escape') {
                closeModal(modalId);
                document.removeEventListener('keydown', escHandler);
            }
        };
        document.addEventListener('keydown', escHandler);
        
        // Focus on the first input if available
        setTimeout(() => {
            const firstInput = modal.querySelector('input, textarea');
            if (firstInput) firstInput.focus();
        }, 100);
    }

    function closeModal(modalId) {
        const modal = document.getElementById(modalId);
        document.body.style.overflow = ''; // Restore scrolling
        modal.classList.remove('active');
        
        // Reset form inputs if any
        const form = modal.querySelector('form');
        if (form) form.reset();
    }

    function showStoryModal() {
        document.getElementById('storyInput').value = '';
        showModal('storyModal');
    }

    function showYtLinkModal() {
        const ytLinkInput = document.getElementById('ytLinkInput');
        const ytAdditionalInput = document.getElementById('ytAdditionalInput');
        if (ytLinkInput && ytAdditionalInput) {
            ytLinkInput.value = '';
            ytAdditionalInput.value = '';
            showModal('ytLinkModal');
        } else {
            console.error('YT link modal elements not found');
        }
    }
    
    async function fetchYouTubeTranscript(videoUrl) {
        try {
            showLoading();
            const response = await fetch('/api/youtube-transcript', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ url: videoUrl })
            });
            hideLoading();
            
            if (!response.ok) throw new Error('Failed to fetch transcript');
            const data = await response.json();
            return data.transcript;
        } catch (error) {
            hideLoading();
            console.error('Transcript fetch error:', error);
            return "Error: Couldn't fetch transcript. Please try again.";
        }
    }
    
    async function submitYtLink() {
        const ytLinkInput = document.getElementById('ytLinkInput');
        const ytAdditionalInput = document.getElementById('ytAdditionalInput');
        const userInput = document.getElementById("userInput");
        const chatBox = document.getElementById("chatBox");
        if (!ytLinkInput || !ytAdditionalInput || !chatBox || !userInput) {
            console.error('YT link modal, userInput, or chatBox not found');
            return;
        }

        const ytLink = ytLinkInput.value.trim();
        const additionalContent = ytAdditionalInput.value.trim();
        if (!ytLink) {
            showNotification('Please enter a YouTube URL.', 'error');
            return;
        }

        closeModal('ytLinkModal');
        
        const loadingBubble = document.createElement("div");
        loadingBubble.className = "chat-bubble ai";
        loadingBubble.textContent = "Fetching YouTube transcript...";
        
        const loadingWrapper = document.createElement("div");
        loadingWrapper.className = "chat-bubble-wrapper ai";
        loadingWrapper.appendChild(loadingBubble);
        
        chatBox.appendChild(loadingWrapper);
        chatBox.scrollTop = chatBox.scrollHeight;

        const transcript = await fetchYouTubeTranscript(ytLink);

        loadingWrapper.remove();

        if (transcript.startsWith("Error:")) {
            const errorBubble = document.createElement("div");
            errorBubble.className = "chat-bubble ai";
            errorBubble.textContent = transcript;
            
            const errorWrapper = document.createElement("div");
            errorWrapper.className = "chat-bubble-wrapper ai";
            errorWrapper.appendChild(errorBubble);
            
            chatBox.appendChild(errorWrapper);
            chatBox.scrollTop = chatBox.scrollHeight;
            showNotification(transcript, 'error');
            return;
        }

        currentTranscript = transcript; // Store the transcript for display
        let fullPrompt = TEMPLATE_TEXT;
        fullPrompt = fullPrompt.replace('[Insert additional context here, if provided.]', additionalContent || '');
        fullPrompt = fullPrompt.replace('[Insert the viral story you provide.]', transcript);
        setPrompt(fullPrompt);
        userInput.value = ''; // Clear the input field
        autoExpand(userInput);
        sendMessage();
        showNotification('YouTube transcript processed successfully!');
    }  

    function submitStory() {
        const storyContent = document.getElementById('storyInput').value.trim();
        const userInput = document.getElementById("userInput");
        if (!storyContent) {
            showNotification('Please paste a Reddit story before submitting.', 'error');
            return;
        }
        
        currentStory = storyContent; // Store the story for display
        const fullPrompt = TEMPLATE_TEXT.replace('[Insert the viral story you provide.]', storyContent);
        setPrompt(fullPrompt);
        userInput.value = ''; // Clear the input field
        autoExpand(userInput);
        closeModal('storyModal');
        sendMessage();
        showNotification('Story submitted successfully!');
    }

    function getSavedSessionNames() {
        const names = getCookie('sessionNames');
        return names ? JSON.parse(names) : {};
    }

    function autoExpand(field) {
        field.style.height = 'auto';
        const maxHeight = parseInt(getComputedStyle(field).maxHeight, 10);
        const newHeight = Math.min(field.scrollHeight, maxHeight);
        field.style.height = newHeight + 'px';
        field.style.overflowY = field.scrollHeight > maxHeight ? 'auto' : 'hidden';
    }

    function setPrompt(prompt) {
        window.currentPrompt = prompt; // Store the prompt internally
    }

    function loadChatHistory() {
        const chatBox = document.getElementById("chatBox");
        chatBox.innerHTML = '<button onclick="toggleFullScreen()" id="fullScreenButton" class="full-screen-button">‚õ∂</button>';
        const currentHistory = chatSessions[currentSessionId] || [];
        if (currentHistory.length === 0) {
            const welcomeBubble = document.createElement("div");
            welcomeBubble.className = "chat-bubble ai";
            welcomeBubble.textContent = "Hey! Add a Reddit story to get started‚ÄîI'll turn it into a fresh script for you.";
            const wrapper = document.createElement("div");
            wrapper.className = "chat-bubble-wrapper ai";
            wrapper.appendChild(welcomeBubble);
            const copyButton = document.createElement("button");
            copyButton.className = "copy-button";
            copyButton.textContent = "üìã";
            copyButton.title = "Copy to clipboard";
            copyButton.onclick = () => copyToClipboard(welcomeBubble.textContent);
            wrapper.appendChild(copyButton);
            chatBox.appendChild(wrapper);
        } else {
            currentHistory.forEach((msg, index) => {
                const bubble = document.createElement("div");
                bubble.className = `chat-bubble ${msg.role}`;
                bubble.textContent = msg.content;
                bubble.dataset.index = index;

                const wrapper = document.createElement("div");
                wrapper.className = `chat-bubble-wrapper ${msg.role}`;
                wrapper.appendChild(bubble);

                if (msg.role === 'assistant') {
                    const quoteButton = document.createElement("button");
                    quoteButton.className = "quote-button";
                    quoteButton.textContent = "üí¨";
                    quoteButton.title = "Quote this response";
                    quoteButton.onclick = () => quoteMessage(bubble);
                    wrapper.appendChild(quoteButton);

                    const retryButton = document.createElement("button");
                    retryButton.className = "retry-button";
                    retryButton.textContent = "üîÑ";
                    retryButton.title = "Regenerate response";
                    retryButton.onclick = () => retryMessage(bubble);
                    wrapper.appendChild(retryButton);

                    const copyButton = document.createElement("button");
                    copyButton.className = "copy-button";
                    copyButton.textContent = "üìã";
                    copyButton.title = "Copy to clipboard";
                    copyButton.onclick = () => copyToClipboard(msg.content);
                    wrapper.appendChild(copyButton);
                } else if (msg.role === 'user') {
                    const editButton = document.createElement("button");
                    editButton.className = "edit-button";
                    editButton.textContent = "‚úèÔ∏è";
                    editButton.title = "Edit this message";
                    editButton.onclick = () => startEditing(bubble);
                    wrapper.appendChild(editButton);
                }

                chatBox.appendChild(wrapper);
            });
        }
        chatBox.scrollTop = chatBox.scrollHeight;
    }

    function startEditing(bubble) {
        if (bubble.classList.contains('editable')) return;

        const wrapper = bubble.parentElement;
        const index = parseInt(bubble.dataset.index, 10);
        const originalText = bubble.textContent.trim();

        bubble.classList.add('editable');
        bubble.innerHTML = '';

        const textarea = document.createElement('textarea');
        textarea.value = originalText;
        textarea.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                finishEditing(bubble, wrapper, index, textarea.value);
            } else if (e.key === 'Escape') {
                cancelEditing(bubble, wrapper, originalText);
            }
        });
        textarea.addEventListener('input', () => autoExpand(textarea));
        bubble.appendChild(textarea);
        textarea.focus();
        autoExpand(textarea);

        wrapper.querySelector('.edit-button').style.display = 'none'; // Hide edit button during edit
    }
    
    async function finishEditing(bubble, wrapper, index, newText) {
        const chatBox = document.getElementById("chatBox");
        const sendButton = document.getElementById("sendStopButton");
        if (!chatBox || !sendButton) return;

        bubble.classList.remove('editable');
        bubble.innerHTML = '';
        bubble.textContent = newText;

        const editButton = wrapper.querySelector('.edit-button');
        editButton.style.display = 'block';

        const currentHistory = chatSessions[currentSessionId];
        currentHistory[index] = { role: 'user', content: newText };
        const newHistory = currentHistory.slice(0, index + 1);

        const allWrappers = Array.from(chatBox.querySelectorAll('.chat-bubble-wrapper'));
        const bubbleIndex = allWrappers.indexOf(wrapper);
        for (let i = allWrappers.length - 1; i > bubbleIndex; i--) {
            chatBox.removeChild(allWrappers[i]);
        }

        chatSessions[currentSessionId] = newHistory;
        setChatSessions(chatSessions);

        isRequestPending = true;
        sendButton.textContent = "‚ñ†";
        sendButton.classList.add("active");

        const thinkingBubble = document.createElement("div");
        thinkingBubble.className = "chat-bubble ai placeholder";
        thinkingBubble.textContent = cookingMessages[Math.floor(Math.random() * cookingMessages.length)];
        const thinkingWrapper = document.createElement("div");
        thinkingWrapper.className = "chat-bubble-wrapper ai";
        thinkingWrapper.appendChild(thinkingBubble);
        chatBox.appendChild(thinkingWrapper);
        chatBox.scrollTop = chatBox.scrollHeight;

        abortController = new AbortController();
        try {
            const response = await fetch("/api/chat", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                signal: abortController.signal,
                body: JSON.stringify({ 
                    message: newText, 
                    apiKey: currentApiKey,
                    chatHistory: newHistory,
                    model: modelSelect.value
                })
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.details || `HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            thinkingWrapper.remove();

            const aiBubble = document.createElement("div");
            aiBubble.className = "chat-bubble ai";
            aiBubble.textContent = data.response;

            const aiWrapper = createAiMessageWrapper(data.response);
            chatBox.appendChild(aiWrapper);

            newHistory.push({ role: 'assistant', content: data.response });
            chatSessions[currentSessionId] = newHistory;
            setChatSessions(chatSessions);

            updateChatList();
            chatBox.scrollTop = chatBox.scrollHeight;
        } catch (error) {
            if (error.name !== 'AbortError') {
                thinkingWrapper.remove();
                const errorBubble = document.createElement("div");
                errorBubble.className = "chat-bubble ai";
                errorBubble.textContent = `Error: ${error.message}`;
                const errorWrapper = document.createElement("div");
                errorWrapper.className = "chat-bubble-wrapper ai";
                errorWrapper.appendChild(errorBubble);

                const quoteButton = document.createElement("button");
                quoteButton.className = "quote-button";
                quoteButton.textContent = "üí¨";
                quoteButton.title = "Quote this response";
                quoteButton.onclick = () => quoteMessage(errorBubble);
                errorWrapper.appendChild(quoteButton);

                const retryButton = document.createElement("button");
                retryButton.className = "retry-button";
                retryButton.textContent = "üîÑ";
                retryButton.title = "Regenerate response";
                retryButton.onclick = () => retryMessage(errorBubble);
                errorWrapper.appendChild(retryButton);

                const copyButton = document.createElement("button");
                copyButton.className = "copy-button";
                copyButton.textContent = "üìã";
                copyButton.title = "Copy to clipboard";
                copyButton.onclick = () => copyToClipboard(errorBubble.textContent);
                errorWrapper.appendChild(copyButton);

                chatBox.appendChild(errorWrapper);
                chatBox.scrollTop = chatBox.scrollHeight;
                
                showNotification(`Error: ${error.message}`, 'error');
            } else {
                thinkingWrapper.remove();
            }
        } finally {
            isRequestPending = false;
            sendButton.textContent = "‚û§";
            sendButton.classList.remove("active");
        }
    }

    function cancelEditing(bubble, wrapper, originalText) {
        bubble.classList.remove('editable');
        bubble.textContent = originalText;
        wrapper.querySelector('.edit-button').style.display = 'block';
    }

    function updateChatList() {
        const chatList = document.getElementById("chatList");
        chatList.innerHTML = '';
        
        sessionNames = getSavedSessionNames();
        
        const currentChatIndicator = document.getElementById("currentChatIndicator");
        const currentChatName = sessionNames[currentSessionId] || "New Chat";
        currentChatIndicator.textContent = currentChatName;
        
        Object.keys(chatSessions).forEach(sessionId => {
            const chatItem = document.createElement("div");
            chatItem.className = "chat-actions";
            
            const button = document.createElement("button");
            button.className = "side-button";
            if (sessionId === currentSessionId) {
                button.classList.add("current");
            }
            
            let sessionName = sessionNames[sessionId];
            if (!sessionName) {
                const chatNumber = Object.keys(sessionNames).length + 1;
                sessionName = `Chat ${chatNumber}`;
                sessionNames[sessionId] = sessionName;
                setCookie('sessionNames', JSON.stringify(sessionNames), 7);
            }
            
            button.textContent = sessionName;
            button.style.width = "85%";
            button.onclick = () => switchChat(sessionId);
            
            const deleteButton = document.createElement("button");
            deleteButton.className = "delete-chat";
            deleteButton.textContent = "√ó";
            deleteButton.title = "Delete chat";
            deleteButton.onclick = (e) => deleteChat(sessionId, e);
            
            chatItem.appendChild(button);
            chatItem.appendChild(deleteButton);
            
            chatList.appendChild(chatItem);
        });
    }

    function newChat() {
        currentSessionId = Date.now().toString();
        chatSessions[currentSessionId] = [];
        const chatNumber = Object.keys(chatSessions).length;
        sessionNames[currentSessionId] = `Chat ${chatNumber}`;
        setChatSessions(chatSessions);
        setCookie('sessionNames', JSON.stringify(sessionNames), 7);
        loadChatHistory();
        updateChatList();
        hideSidebar();
        showNotification('New chat created!');
    }

    function switchChat(sessionId) {
        if (!chatSessions[sessionId]) {
            console.error("Session not found:", sessionId);
            return;
        }
        
        currentSessionId = sessionId;
        
        const currentChatIndicator = document.getElementById("currentChatIndicator");
        if (currentChatIndicator) {
            const currentChatName = sessionNames[sessionId] || "New Chat";
            currentChatIndicator.textContent = currentChatName;
        }
        
        loadChatHistory();
        updateChatList();
        hideSidebar();
    }

    function toggleSideExtension() {
        const sideExtension = document.getElementById("sideExtension");
        
        if (sideExtension.classList.contains("active")) {
            sideExtension.classList.remove("active");
            sideExtension.classList.remove("edge-only");
        } else {
            sideExtension.classList.add("active");
            sideExtension.classList.remove("edge-only");
        }
    }
    
    function hideSidebar() {
        const sideExtension = document.getElementById("sideExtension");
        sideExtension.classList.remove("active");
        sideExtension.classList.remove("edge-only");
    }
    
    function deleteChat(sessionId, event) {
        event.stopPropagation();
        
        if (confirm("Are you sure you want to delete this chat?")) {
            delete chatSessions[sessionId];
            delete sessionNames[sessionId];
            setChatSessions(chatSessions);
            setCookie('sessionNames', JSON.stringify(sessionNames), 7);
            
            if (sessionId === currentSessionId) {
                const remainingSessions = Object.keys(chatSessions);
                if (remainingSessions.length > 0) {
                    currentSessionId = remainingSessions[0];
                } else {
                    currentSessionId = Date.now().toString();
                    chatSessions[currentSessionId] = [];
                    sessionNames[currentSessionId] = `Chat 1`;
                    setChatSessions(chatSessions);
                    setCookie('sessionNames', JSON.stringify(sessionNames), 7);
                }
                loadChatHistory();
            }
            
            updateChatList();
            showNotification('Chat deleted');
        }
    }

    function toggleSendStop() {
        if (isRequestPending) {
            if (abortController) {
                abortController.abort();
                isRequestPending = false;
                const sendButton = document.getElementById("sendStopButton");
                sendButton.textContent = "‚û§";
                sendButton.classList.remove("active");
                const chatBox = document.getElementById("chatBox");
                const thinkingBubble = chatBox.querySelector(".chat-bubble.ai.placeholder");
                if (thinkingBubble) thinkingBubble.parentElement.remove();
                showNotification('Request canceled');
            }
        } else {
            sendMessage();
        }
    }

    // Notification function - creates a temporary notification
    function showNotification(message, type = 'success') {
        // Remove any existing notifications
        const existingNotification = document.querySelector('.success-notification');
        if (existingNotification) {
            existingNotification.remove();
        }
        
        // Create notification element
        const notification = document.createElement('div');
        notification.className = 'success-notification';
        notification.textContent = message;
        
        if (type === 'error') {
            notification.style.background = 'linear-gradient(135deg, #FF5555, #CC4444)';
            notification.classList.add('error-notification');
        }
        
        // Add to body
        document.body.appendChild(notification);
        
        // Remove after animation completes
        setTimeout(() => {
            if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
            }
        }, 3000);
    }
    
    // Save Script - improved with proper script extraction
    async function saveScript() {
        const currentHistory = chatSessions[currentSessionId] || [];
        
        if (currentHistory.length === 0) {
            showNotification('No script found to save! Please generate a script first.', 'error');
            return;
        }
        
        // Find the most recent AI message that contains a script
        let scriptContent = null;
        let scriptIndex = -1;
        
        for (let i = currentHistory.length - 1; i >= 0; i--) {
            const msg = currentHistory[i];
            if (msg.role === 'assistant') {
                scriptContent = msg.content;
                scriptIndex = i;
                break;
            }
        }
        
        if (scriptIndex === -1) {
            showNotification('No script found to save! Please generate a script first.', 'error');
            return;
        }
        
        // Validate script contains proper markers
        if (!scriptContent.includes("=== SCRIPT START ===") || !scriptContent.includes("=== SCRIPT END ===")) {
            showNotification('The last message does not contain a valid script with START and END markers.', 'error');
            return;
        }
        
        // Extract just the script part between the markers
        const scriptMatch = scriptContent.match(/=== SCRIPT START ===\n([\s\S]*?)\n=== SCRIPT END ===/);
        if (!scriptMatch || !scriptMatch[1]) {
            showNotification('Could not extract script content properly.', 'error');
            return;
        }
        
        const extractedScript = scriptMatch[1].trim();
        
        // Check for duplicate script in the saved scripts
        try {
            const savedScripts = await fetchSavedScripts();
            const isDuplicate = savedScripts.some(script => script.content.trim() === extractedScript);
            
            if (isDuplicate) {
                showNotification('This script has already been saved! Please generate a new script.', 'error');
                return;
            }
            
            // If all validation passes, save the script
            saveScriptToServer(scriptContent);
        } catch (error) {
            console.error('Error checking for duplicate scripts:', error);
            showNotification('Error verifying script uniqueness. Please try again.', 'error');
        }
    }
    
    // Direct save to server function
    async function saveScriptToServer(scriptContent) {
        try {
            // Extract just the script part between the markers
            const scriptMatch = scriptContent.match(/=== SCRIPT START ===\n([\s\S]*?)\n=== SCRIPT END ===/);
            if (!scriptMatch || !scriptMatch[1]) {
                throw new Error('Could not extract script content');
            }
            
            const extractedScript = scriptMatch[1].trim();
            
            // Create loading indicator
            const chatBox = document.getElementById("chatBox");
            const loadingBubble = document.createElement("div");
            loadingBubble.className = "chat-bubble ai placeholder";
            loadingBubble.textContent = "Saving script...";
            const loadingWrapper = document.createElement("div");
            loadingWrapper.className = "chat-bubble-wrapper ai";
            loadingWrapper.appendChild(loadingBubble);
            chatBox.appendChild(loadingWrapper);
            chatBox.scrollTop = chatBox.scrollHeight;
            
            // Send the script to the server for saving
            const response = await fetch('/api/save-script', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ 
                    scriptContent: extractedScript,
                    timestamp: new Date().toISOString()
                })
            });
            
            // Remove the loading indicator
            loadingWrapper.remove();
            
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || `Server error: ${response.status}`);
            }
            
            // Add success message
            const successBubble = document.createElement("div");
            successBubble.className = "chat-bubble ai";
            successBubble.textContent = "Script saved successfully! You can view it in the Settings menu.";
            const successWrapper = document.createElement("div");
            successWrapper.className = "chat-bubble-wrapper ai";
            successWrapper.appendChild(successBubble);
            
            // Add action buttons to the success message
            const quoteButton = document.createElement("button");
            quoteButton.className = "quote-button";
            quoteButton.textContent = "üí¨";
            quoteButton.title = "Quote this response";
            quoteButton.onclick = () => quoteMessage(successBubble);
            successWrapper.appendChild(quoteButton);
            
            const copyButton = document.createElement("button");
            copyButton.className = "copy-button";
            copyButton.textContent = "üìã";
            copyButton.title = "Copy to clipboard";
            copyButton.onclick = () => copyToClipboard(successBubble.textContent);
            successWrapper.appendChild(copyButton);
            
            chatBox.appendChild(successWrapper);
            chatBox.scrollTop = chatBox.scrollHeight;
            
            // Update chat history
            const currentHistory = chatSessions[currentSessionId];
            currentHistory.push({ role: 'assistant', content: "Script saved successfully! You can view it in the Settings menu." });
            chatSessions[currentSessionId] = currentHistory;
            setChatSessions(chatSessions);
            
            // Show a floating notification
            showNotification('Script saved successfully!');
            
        } catch (error) {
            console.error('Error saving script:', error);
            
            // Show error message
            const chatBox = document.getElementById("chatBox");
            const errorBubble = document.createElement("div");
            errorBubble.className = "chat-bubble ai";
            errorBubble.textContent = `Error saving script: ${error.message}`;
            const errorWrapper = document.createElement("div");
            errorWrapper.className = "chat-bubble-wrapper ai";
            errorWrapper.appendChild(errorBubble);
            
            const retryButton = document.createElement("button");
            retryButton.className = "retry-button";
            retryButton.textContent = "üîÑ";
            retryButton.title = "Try again";
            retryButton.onclick = () => saveScript();
            errorWrapper.appendChild(retryButton);
            
            chatBox.appendChild(errorWrapper);
            chatBox.scrollTop = chatBox.scrollHeight;
            
            // Show notification
            showNotification(`Error saving script: ${error.message}`, 'error');
        }
    }

    // Improved copy to clipboard with notification
    function copyToClipboard(text) {
        navigator.clipboard.writeText(text).then(() => {
            showNotification('Copied to clipboard!');
        }).catch(err => {
            console.error('Failed to copy:', err);
            showNotification('Failed to copy to clipboard', 'error');
        });
    }

    async function sendMessage() {
        if (isRequestPending) {
            return; // Silently prevent sending
        }
    
        const userInput = document.getElementById("userInput");
        const chatBox = document.getElementById("chatBox");
        const sendButton = document.getElementById("sendStopButton");
        const message = userInput.value.trim();
        const modelSelect = document.getElementById('modelSelect');
    
        if (!message && !window.currentPrompt) return;
        if (!currentApiKey) return;
    
        isRequestPending = true;
        sendButton.textContent = "‚ñ†";
        sendButton.classList.add("active");
    
        const currentHistory = chatSessions[currentSessionId] || [];
        let editedBubble = chatBox.querySelector('.chat-bubble.editable');
        let editedIndex = editedBubble ? parseInt(editedBubble.dataset.index, 10) : -1;
    
        let displayMessage = message;
        let messageToSend = message;
        
        if (!message && window.currentPrompt) {
            displayMessage = window.currentPrompt;
            messageToSend = window.currentPrompt;
        }
        
        if (editedIndex !== -1) {
            editedBubble.textContent = displayMessage;
            editedBubble.classList.remove('editable');
            const wrapper = editedBubble.parentElement;
            wrapper.innerHTML = ''; // Clear wrapper
            wrapper.appendChild(editedBubble);
            const editButton = document.createElement("button");
            editButton.className = "edit-button";
            editButton.textContent = "‚úèÔ∏è";
            editButton.title = "Edit this message";
            editButton.onclick = () => startEditing(editedBubble);
            wrapper.appendChild(editButton);
        } else {
            const userBubble = document.createElement("div");
            userBubble.className = "chat-bubble user";
            userBubble.textContent = displayMessage;
            userBubble.dataset.index = currentHistory.length;
    
            const wrapper = document.createElement("div");
            wrapper.className = "chat-bubble-wrapper user";
            wrapper.appendChild(userBubble);
    
            const editButton = document.createElement("button");
            editButton.className = "edit-button";
            editButton.textContent = "‚úèÔ∏è";
            editButton.title = "Edit this message";
            editButton.onclick = () => startEditing(userBubble);
            wrapper.appendChild(editButton);
    
            chatBox.appendChild(wrapper);
        }
    
        const thinkingBubble = document.createElement("div");
        thinkingBubble.className = "chat-bubble ai placeholder";
        thinkingBubble.textContent = cookingMessages[Math.floor(Math.random() * cookingMessages.length)];
        const thinkingWrapper = document.createElement("div");
        thinkingWrapper.className = "chat-bubble-wrapper ai";
        thinkingWrapper.appendChild(thinkingBubble);
        chatBox.appendChild(thinkingWrapper);
    
        userInput.value = "";
        autoExpand(userInput);
        chatBox.scrollTop = chatBox.scrollHeight;
    
        abortController = new AbortController();
        
        try {
            // Prepare request body
            const requestBody = {
                message: messageToSend, 
                apiKey: currentApiKey,
                chatHistory: currentHistory,
                model: modelSelect.value
            };
    
            // If editing an existing message, modify history
            if (editedIndex !== -1) {
                currentHistory[editedIndex] = { role: 'user', content: displayMessage };
                currentHistory.splice(editedIndex + 1);
            } else {
                currentHistory.push({ role: 'user', content: displayMessage });
            }
    
            const response = await fetch("/api/chat", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                signal: abortController.signal,
                body: JSON.stringify(requestBody)
            });
    
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.details || `HTTP error! status: ${response.status}`);
            }
    
            const data = await response.json();
            thinkingWrapper.remove();
    
            const aiWrapper = createAiMessageWrapper(data.response);
            chatBox.appendChild(aiWrapper);
    
            currentHistory.push({ role: 'assistant', content: data.response });
            chatSessions[currentSessionId] = currentHistory;
            setChatSessions(chatSessions);
    
            updateChatList();
            chatBox.scrollTop = chatBox.scrollHeight;
    
            // Reset window.currentPrompt after use to prevent reuse
            window.currentPrompt = null;
            currentStory = ''; // Clear stored story
            currentTranscript = ''; // Clear stored transcript
    
        } catch (error) {
            console.error('Full error details:', error);
    
            if (error.name !== 'AbortError') {
                thinkingWrapper.remove();
                const errorBubble = document.createElement("div");
                errorBubble.className = "chat-bubble ai";
                errorBubble.textContent = `Error: ${error.message}`;
                const errorWrapper = document.createElement("div");
                errorWrapper.className = "chat-bubble-wrapper ai";
                errorWrapper.appendChild(errorBubble);
    
                const quoteButton = document.createElement("button");
                quoteButton.className = "quote-button";
                quoteButton.textContent = "üí¨";
                quoteButton.title = "Quote this response";
                quoteButton.onclick = () => quoteMessage(errorBubble);
                errorWrapper.appendChild(quoteButton);
    
                const retryButton = document.createElement("button");
                retryButton.className = "retry-button";
                retryButton.textContent = "üîÑ";
                retryButton.title = "Regenerate response";
                retryButton.onclick = () => retryMessage(errorBubble);
                errorWrapper.appendChild(retryButton);
    
                const copyButton = document.createElement("button");
                copyButton.className = "copy-button";
                copyButton.textContent = "üìã";
                copyButton.title = "Copy to clipboard";
                copyButton.onclick = () => copyToClipboard(errorBubble.textContent);
                errorWrapper.appendChild(copyButton);
    
                chatBox.appendChild(errorWrapper);
                chatBox.scrollTop = chatBox.scrollHeight;
                
                showNotification(`Error: ${error.message}`, 'error');
            } else {
                thinkingWrapper.remove();
            }
        } finally {
            isRequestPending = false;
            sendButton.textContent = "‚û§";
            sendButton.classList.remove("active");
            userInput.value = ""; // Redundant clear to ensure input is empty
            autoExpand(userInput);
        }
    }

    async function retryMessage(aiBubble) {
        if (isRequestPending) return;
    
        const chatBox = document.getElementById("chatBox");
        const sendButton = document.getElementById("sendStopButton");
        const modelSelect = document.getElementById('modelSelect');
        
        // Find the clicked AI message's wrapper
        const wrapper = aiBubble.parentElement;
        const allWrappers = Array.from(chatBox.querySelectorAll('.chat-bubble-wrapper'));
        
        // Get the index of this AI message's wrapper in the DOM
        const aiIndex = allWrappers.indexOf(wrapper);
        
        // Find the corresponding user message right before this AI message
        const userWrapper = allWrappers[aiIndex - 1];
        if (!userWrapper || !userWrapper.classList.contains('user')) {
            showNotification("No preceding user message found to regenerate.", "error");
            return;
        }
        
        // Get the user message content
        const userBubble = userWrapper.querySelector('.chat-bubble');
        const prompt = userBubble.textContent;
        
        // Get the bubble's dataset index to find the message in chat history
        const bubbleIndex = parseInt(userBubble.dataset.index, 10);
        if (isNaN(bubbleIndex)) {
            showNotification("Could not determine message index.", "error");
            return;
        }
        
        // Create truncated history up to and including this user message
        const currentHistory = chatSessions[currentSessionId];
        const newHistory = currentHistory.slice(0, bubbleIndex + 1);
        
        // Update chat history in storage
        chatSessions[currentSessionId] = newHistory;
        setChatSessions(chatSessions);
        
        // Remove all messages after this user message in the DOM
        for (let i = allWrappers.length - 1; i > aiIndex - 1; i--) {
            chatBox.removeChild(allWrappers[i]);
        }
        
        // Start generating new response
        isRequestPending = true;
        sendButton.textContent = "‚ñ†";
        sendButton.classList.add("active");
        
        // Add thinking bubble
        const thinkingBubble = document.createElement("div");
        thinkingBubble.className = "chat-bubble ai placeholder";
        thinkingBubble.textContent = cookingMessages[Math.floor(Math.random() * cookingMessages.length)];
        const thinkingWrapper = document.createElement("div");
        thinkingWrapper.className = "chat-bubble-wrapper ai";
        thinkingWrapper.appendChild(thinkingBubble);
        chatBox.appendChild(thinkingWrapper);
        chatBox.scrollTop = chatBox.scrollHeight;
        
        abortController = new AbortController();
        
        try {
            const response = await fetch("/api/chat", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                signal: abortController.signal,
                body: JSON.stringify({ 
                    message: prompt, 
                    apiKey: currentApiKey,
                    chatHistory: newHistory.slice(0, -1), // Don't include the last message (user prompt) in history
                    isRetry: true,
                    model: modelSelect.value
                })
            });
            
            // Process response and update UI
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.details || `HTTP error! status: ${response.status}`);
            }
            
            const data = await response.json();
            thinkingWrapper.remove();
            
            // Create new AI response bubble
            const aiWrapper = createAiMessageWrapper(data.response);
            chatBox.appendChild(aiWrapper);
            
            // Update chat history with new AI response
            newHistory.push({ role: 'assistant', content: data.response });
            chatSessions[currentSessionId] = newHistory;
            setChatSessions(chatSessions);
            
            updateChatList();
            chatBox.scrollTop = chatBox.scrollHeight;
            
            showNotification("Response regenerated!");
            
        } catch (error) {
            // Error handling remains the same
            if (error.name !== 'AbortError') {
                thinkingWrapper.remove();
                const errorBubble = document.createElement("div");
                errorBubble.className = "chat-bubble ai";
                errorBubble.textContent = `Error: ${error.message}`;
                const errorWrapper = document.createElement("div");
                errorWrapper.className = "chat-bubble-wrapper ai";
                errorWrapper.appendChild(errorBubble);
                
                // Add buttons to error message
                const quoteButton = document.createElement("button");
                quoteButton.className = "quote-button";
                quoteButton.textContent = "üí¨";
                quoteButton.title = "Quote this response";
                quoteButton.onclick = () => quoteMessage(errorBubble);
                errorWrapper.appendChild(quoteButton);
                
                const retryButton = document.createElement("button");
                retryButton.className = "retry-button";
                retryButton.textContent = "üîÑ";
                retryButton.title = "Regenerate response";
                retryButton.onclick = () => retryMessage(errorBubble);
                errorWrapper.appendChild(retryButton);
                
                const copyButton = document.createElement("button");
                copyButton.className = "copy-button";
                copyButton.textContent = "üìã";
                copyButton.title = "Copy to clipboard";
                copyButton.onclick = () => copyToClipboard(errorBubble.textContent);
                errorWrapper.appendChild(copyButton);
                
                chatBox.appendChild(errorWrapper);
                chatBox.scrollTop = chatBox.scrollHeight;
                
                showNotification(`Error: ${error.message}`, 'error');
            } else {
                thinkingWrapper.remove();
            }
        } finally {
            isRequestPending = false;
            sendButton.textContent = "‚û§";
            sendButton.classList.remove("active");
        }
    }

    function quoteMessage(aiBubble) {
        const selection = window.getSelection().toString().trim();
        const textToQuote = selection || aiBubble.textContent;
        const userInput = document.getElementById("userInput");
        userInput.value = `> ${textToQuote}\n\n`;
        autoExpand(userInput);
        userInput.focus();
    }
    
    function toggleSettings() {
        const menu = document.getElementById('settingsMenu');
        menu.classList.toggle('active');
    }

    function showKeys() {
        document.getElementById('accessKeyDisplay').textContent = currentAccessKey || 'Not set';
        document.getElementById('apiKeyDisplay').textContent = currentApiKey || 'Not set';
        showModal('keysModal');
        document.getElementById('settingsMenu').classList.remove('active');
    }

    function showSavedScripts() {
        document.getElementById('settingsMenu').classList.remove('active');
        const modal = document.getElementById('savedScriptsModal');
        const list = document.getElementById('savedScriptsList');
        list.innerHTML = 'Loading...';
        showModal('savedScriptsModal');

        fetchSavedScripts().then(scripts => {
            list.innerHTML = '';
            if (!scripts || scripts.length === 0) {
                list.textContent = 'No saved scripts yet!';
                return;
            }
            scripts.forEach((script, index) => {
                const scriptDiv = document.createElement('div');
                scriptDiv.className = 'saved-script';
                scriptDiv.style.display = 'flex';
                scriptDiv.style.alignItems = 'center';

                const scriptText = document.createElement('span');
                scriptText.textContent = script.content;
                scriptText.style.flexGrow = '1';
                scriptDiv.appendChild(scriptText);

                const deleteButton = document.createElement("button");
                deleteButton.className = "saved-script-delete-button";
                deleteButton.textContent = "Delete";
                deleteButton.onclick = () => deleteSavedScript(script.timestamp);
                scriptDiv.appendChild(deleteButton);

                list.appendChild(scriptDiv);
                if (index < scripts.length - 1) {
                    const separator = document.createElement('div');
                    separator.className = 'script-separator';
                    list.appendChild(separator);
                }
            });
        });
    }
    
    async function deleteSavedScript(timestamp) {
        if (confirm("Are you sure you want to delete this script?")) {
            try {
                showLoading();
                const response = await fetch('/api/delete-saved-script', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ timestamp })
                });
                hideLoading();
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Failed to delete script');
                }
                showSavedScripts(); // Refresh the list
                showNotification('Script deleted successfully!');
            } catch (error) {
                hideLoading();
                console.error('Error deleting script:', error);
                showNotification(`Failed to delete script: ${error.message}`, 'error');
            }
        }
    }
    
    async function clearSavedScripts() {
        if (confirm('Are you sure you want to clear all saved scripts?')) {
            try {
                const list = document.getElementById('savedScriptsList');
                list.innerHTML = 'Clearing scripts...';
                
                showLoading();
                const response = await fetch('/api/clear-saved-scripts', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                hideLoading();
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Failed to clear scripts');
                }
                
                const result = await response.json();
                console.log('Clear scripts result:', result);
                
                list.textContent = 'No saved scripts yet!';
                
                showNotification('Scripts cleared successfully!');
            } catch (error) {
                hideLoading();
                console.error('Error clearing saved scripts:', error);
                showNotification(`Failed to clear scripts: ${error.message}`, 'error');
            }
        }
    }

    function downloadScripts() {
        fetchSavedScripts().then(scripts => {
            if (scripts.length === 0) {
                showNotification('No scripts to download!', 'error');
                return;
            }
            const content = scripts.map(s => s.content).join('\n\n---\n\n');
            const blob = new Blob([content], { type: 'text/plain' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'saved_scripts.txt';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
            showNotification('Scripts downloaded!');
        });
    }
    
    function toggleTheme() {
        const body = document.body;
        const themeToggle = document.getElementById('themeToggle');
        const currentTheme = body.getAttribute('data-theme');
        
        body.setAttribute('data-theme-transitioning', 'true');
        
        if (currentTheme === 'light') {
            body.removeAttribute('data-theme');
            themeToggle.textContent = '‚òÄÔ∏è To Light';
            setCookie('theme', 'dark', 7);
        } else {
            body.setAttribute('data-theme', 'light');
            themeToggle.textContent = 'üåô To Dark';
            setCookie('theme', 'light', 7);
        }
        
        // Remove transitioning class after animation completes
        setTimeout(() => {
            body.removeAttribute('data-theme-transitioning');
        }, 500);
        
        document.getElementById('settingsMenu').classList.remove('active');
        showNotification(`Theme switched to ${currentTheme === 'light' ? 'dark' : 'light'} mode`);
    }

    function toggleFullScreen() {
        const chatContainer = document.getElementById('chatInterface');
        chatContainer.classList.toggle('full-screen');
        
        if (chatContainer.classList.contains('full-screen')) {
            document.documentElement.style.overflow = 'hidden';
            showNotification('Fullscreen mode enabled');
        } else {
            document.documentElement.style.overflow = '';
            showNotification('Fullscreen mode disabled');
        }
    }
    
    function logout() {
        if (confirm('Are you sure you want to log out?')) {
            currentAccessKey = '';
            currentApiKey = '';
            currentSessionId = Date.now().toString();
            chatSessions[currentSessionId] = [];
            sessionNames[currentSessionId] = `Script #1`;
            setChatSessions(chatSessions);
            setCookie('sessionNames', JSON.stringify(sessionNames), 7);
            
            deleteCookie('accessKey');
            deleteCookie('apiKey');
            
            document.getElementById('accessKey').value = '';
            document.getElementById('apiKey').value = '';
            
            document.getElementById('accessKeyMessage').style.opacity = '0';
            document.getElementById('apiKeyMessage').style.opacity = '0';
            
            document.getElementById('chatInterface').style.display = 'none';
            document.getElementById('settingsMenu').classList.remove('active');
            document.getElementById('settingsButton').style.display = 'none';
            
            document.getElementById('accessKeyLogin').style.display = 'flex';
            
            document.getElementById('chatBox').innerHTML = '';
            
            showNotification('Logged out successfully');
        }
    }

    // Full page loading animation
    function showLoading() {
        const loader = document.createElement('div');
        loader.className = 'full-page-loader';
        loader.innerHTML = `
            <div class="loader-content">
                <div class="spinner"></div>
                <div class="loader-text">Loading...</div>
            </div>
        `;
        document.body.appendChild(loader);
    }

    function hideLoading() {
        const loader = document.querySelector('.full-page-loader');
        if (loader) {
            loader.classList.add('fade-out');
            setTimeout(() => {
                if (loader.parentNode) {
                    loader.parentNode.removeChild(loader);
                }
            }, 500);
        }
    }

    // Enhanced animation helpers
    document.addEventListener("DOMContentLoaded", function() {
        const savedAccessKey = getCookie('accessKey');
        const savedApiKey = getCookie('apiKey');
        const savedTheme = getCookie('theme');
        const themeToggle = document.getElementById('themeToggle');
        
        if (savedTheme === 'light') {
            document.body.setAttribute('data-theme', 'light');
            themeToggle.textContent = 'üåô To Dark';
        } else {
            document.body.removeAttribute('data-theme');
            themeToggle.textContent = '‚òÄÔ∏è To Light';
        }

        if (savedAccessKey && savedApiKey) {
            currentAccessKey = savedAccessKey;
            currentApiKey = savedApiKey;
            document.getElementById('accessKeyLogin').style.display = 'none';
            document.getElementById('apiKeyLogin').style.display = 'none';
            document.getElementById('chatInterface').style.display = 'flex';
            document.getElementById('settingsButton').style.display = 'block';
            
            const sideExtension = document.getElementById("sideExtension");
            sideExtension.classList.remove("active");
            sideExtension.classList.remove("edge-only");
            
            loadChatHistory();
            updateChatList();
        }

        const accessKeyInput = document.getElementById('accessKey');
        const apiKeyInput = document.getElementById('apiKey');
        const userInput = document.getElementById("userInput");
        const ytLinkInput = document.getElementById("ytLinkInput");

        accessKeyInput.addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                verifyAccessKey();
            }
        });

        apiKeyInput.addEventListener('keypress', function(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                verifyApiKey();
            }
        });

        userInput.addEventListener("keypress", function(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        });
        
        if (ytLinkInput) {
            ytLinkInput.addEventListener('keypress', function(event) {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    submitYtLink();
                }
            });
        }

        // Add animation classes to elements when they come into view
        const animateOnScroll = () => {
            const elements = document.querySelectorAll('.animate-on-scroll:not(.animated)');
            elements.forEach(element => {
                const elementTop = element.getBoundingClientRect().top;
                const elementVisible = 150;
                if (elementTop < window.innerHeight - elementVisible) {
                    element.classList.add('animated');
                }
            });
        };
        
        // Initial check and scroll listener
        animateOnScroll();
        window.addEventListener('scroll', animateOnScroll);
        
        // Add animation classes to chat-bubble elements
        const chatBox = document.getElementById('chatBox');
        if (chatBox) {
            const observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    if (mutation.addedNodes.length) {
                        mutation.addedNodes.forEach((node) => {
                            if (node.classList && node.classList.contains('chat-bubble-wrapper')) {
                                node.classList.add('animate-in');
                                setTimeout(() => {
                                    node.classList.remove('animate-in');
                                }, 500);
                            }
                        });
                    }
                });
            });
            
            observer.observe(chatBox, { childList: true });
        }

        document.addEventListener('click', function(event) {
            const settingsMenu = document.getElementById('settingsMenu');
            const settingsButton = document.getElementById('settingsButton');
            const sideExtension = document.getElementById('sideExtension');
            const sidebarToggle = document.getElementById('sidebarToggle');
            
            if (settingsMenu && settingsButton && !settingsButton.contains(event.target) && !settingsMenu.contains(event.target)) {
                settingsMenu.classList.remove('active');
            }
            
            if (sideExtension && sideExtension.classList.contains('active') && 
                sidebarToggle && !sideExtension.contains(event.target) && 
                !sidebarToggle.contains(event.target)) {
                hideSidebar();
            }
            
            // Close any modal when clicking outside
            const activeModal = document.querySelector('.modal.active');
            if (activeModal && event.target === activeModal) {
                closeModal(activeModal.id);
            }
        });

        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                const chatContainer = document.getElementById('chatInterface');
                if (chatContainer.classList.contains('full-screen')) {
                    chatContainer.classList.remove('full-screen');
                    document.documentElement.style.overflow = '';
                }
                
                // Close any active modal
                const activeModal = document.querySelector('.modal.active');
                if (activeModal) {
                    closeModal(activeModal.id);
                }
                
                // Close settings menu
                const settingsMenu = document.getElementById('settingsMenu');
                if (settingsMenu && settingsMenu.classList.contains('active')) {
                    settingsMenu.classList.remove('active');
                }
            }
        });

        autoExpand(userInput);
        setupMobileOptimizations();
    });
    
    // Improved mobile experience
    function setupMobileOptimizations() {
        const isMobile = window.innerWidth < 768;
        
        if (isMobile) {
            // Add touch-specific classes
            document.body.classList.add('mobile-device');
            
            // Adjust text areas for better mobile typing
            const textareas = document.querySelectorAll('textarea');
            textareas.forEach(textarea => {
                textarea.addEventListener('focus', () => {
                    // Scroll the page after a short delay to ensure the textarea is visible
                    setTimeout(() => {
                        textarea.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }, 300);
                });
            });
        } else {
            document.body.classList.remove('mobile-device');
        }
    }

    // Initialize mobile optimizations
    window.addEventListener('resize', setupMobileOptimizations);
    
    // Modify input row positioning
    const styleUpdate = `
        .input-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .model-select-container {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: 10px;
            width: 180px;
        }
        
        #modelSelect {
            width: 100%;
            font-size: 14px;
            padding: 6px 10px;
        }
    `;
    
    // Append positioning styles
    const positionStyleElement = document.createElement('style');
    positionStyleElement.textContent = styleUpdate;
    document.head.appendChild(positionStyleElement);
    </script>
</body>
</html>